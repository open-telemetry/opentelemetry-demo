name: Build Images - TEST

"on":
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag for the images (e.g., 2.1.3-test)'
        required: true
        type: string
        default: 'test'
      services:
        description: 'Services to build (comma-separated, or "all" for all services with build:true)'
        required: false
        type: string
        default: 'all'
      no_cache:
        description: 'Disable build cache'
        required: false
        type: boolean
        default: false

jobs:
  prepare-matrix:
    # Only run in forks, not in the main splunk/opentelemetry-demo repo
    if: github.repository != 'splunk/opentelemetry-demo'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      registry: ${{ steps.set-matrix.outputs.registry }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Generate build matrix
        id: set-matrix
        run: |
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import json
          import os

          # Read services.yaml for service configuration
          with open('services.yaml', 'r') as f:
              config = yaml.safe_load(f)

          # Get dev registry from dev-repo.yaml (fork-specific, gitignored)
          # Fallback to auto-detect from GitHub repo info if dev-repo.yaml doesn't exist
          dev_registry = None
          try:
              with open('dev-repo.yaml', 'r') as f:
                  dev_config = yaml.safe_load(f)
                  dev_registry = dev_config.get('registry', {}).get('dev')
          except FileNotFoundError:
              print("âš ï¸  dev-repo.yaml not found, using auto-detected registry")

          if not dev_registry:
              # Fallback: construct from GitHub repository owner and name
              repo_owner = "${{ github.repository_owner }}"
              repo_name = "${{ github.event.repository.name }}"
              dev_registry = f"ghcr.io/{repo_owner}/{repo_name}"
              print(f"ðŸ“¦ Auto-detected registry: {dev_registry}")

          registry = dev_registry
          print(f"Using registry: {registry}")

          # Get services to build
          requested = "${{ inputs.services }}".strip()
          services_to_build = []

          for svc in config.get('services', []):
              name = svc.get('name')
              should_build = svc.get('build', False)

              if not should_build:
                  continue

              # Check if this service should be built
              if requested == 'all':
                  include = True
              else:
                  requested_list = [s.strip() for s in requested.split(',')]
                  include = name in requested_list

              if include:
                  # Get platform (default to multi-arch)
                  platform = svc.get('platform', 'linux/amd64,linux/arm64')

                  # Get dockerfile path (default to standard location)
                  dockerfile = svc.get('dockerfile', f'src/{name}/Dockerfile')

                  services_to_build.append({
                      'name': name,
                      'platform': platform,
                      'dockerfile': dockerfile
                  })

          # Create matrix - ensure at least a dummy entry to avoid GitHub Actions error
          if not services_to_build:
              # Add dummy entry that will be skipped
              matrix = {'include': [{'name': '_skip', 'platform': 'linux/amd64', 'dockerfile': 'none'}]}
          else:
              matrix = {'include': services_to_build}

          # Output to GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'matrix={json.dumps(matrix)}\n')
              f.write(f'registry={registry}\n')

          print(f"Registry: {registry}")
          print(f"Services to build: {len(services_to_build)}")
          if services_to_build:
              for svc in services_to_build:
                  print(f"  - {svc['name']} (platform: {svc['platform']})")
          else:
              print("  (none - dummy matrix entry added)")
          PYTHON_SCRIPT

      - name: Summary
        run: |
          echo "### Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** \`${{ steps.set-matrix.outputs.registry }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Services:** \`${{ inputs.services }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **No Cache:** ${{ inputs.no_cache }}" >> $GITHUB_STEP_SUMMARY

  build-images:
    needs: prepare-matrix
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
      - name: Check if this is a dummy run
        id: check-skip
        run: |
          if [[ "${{ matrix.name }}" == "_skip" ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "This is a dummy matrix entry - skipping all steps"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        if: steps.check-skip.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: steps.check-skip.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.check-skip.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image name
        if: steps.check-skip.outputs.skip != 'true'
        id: image
        run: |
          SERVICE_NAME="${{ matrix.name }}"
          REGISTRY="${{ needs.prepare-matrix.outputs.registry }}"

          # Determine image name based on service
          # Most services use otel-{service} naming convention
          case "$SERVICE_NAME" in
            accounting|ad|cart|fraud-detection|frontend|frontend-proxy|image-provider|llm|payment|product-reviews|recommendation)
              IMAGE_NAME="otel-${SERVICE_NAME}"
              ;;
            *)
              IMAGE_NAME="${SERVICE_NAME}"
              ;;
          esac

          FULL_IMAGE="${REGISTRY}/${IMAGE_NAME}:${{ inputs.version }}"

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT

          echo "Building: ${FULL_IMAGE}"

      - name: Check for Dockerfile
        if: steps.check-skip.outputs.skip != 'true'
        id: check
        run: |
          if [ -f "${{ matrix.dockerfile }}" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Dockerfile found: ${{ matrix.dockerfile }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Dockerfile not found: ${{ matrix.dockerfile }}"
          fi

      - name: Build and push image
        if: steps.check-skip.outputs.skip != 'true' && steps.check.outputs.exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.image.outputs.full_image }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ inputs.no_cache }}

      - name: Image info
        if: steps.check-skip.outputs.skip != 'true' && steps.check.outputs.exists == 'true'
        run: |
          echo "### âœ… Image Built: ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Service | \`${{ matrix.name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ steps.image.outputs.full_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | \`${{ matrix.platform }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Dockerfile | \`${{ matrix.dockerfile }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: Skip notice
        if: steps.check-skip.outputs.skip != 'true' && steps.check.outputs.exists == 'false'
        run: |
          echo "### âš ï¸ Skipped: ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Dockerfile not found at: \`${{ matrix.dockerfile }}\`" >> $GITHUB_STEP_SUMMARY

  update-service-versions:
    needs: [prepare-matrix, build-images]
    if: ${{ success() }}
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Update service versions
        run: |
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import os

          # Get version and services from workflow inputs
          version = "${{ inputs.version }}"
          services_input = "${{ inputs.services }}".strip()

          print(f"Updating service versions to: {version}")
          print(f"Services built: {services_input}")

          # Check if version tracking file exists, create if not
          if not os.path.exists('.service-versions.yaml'):
              print("âš ï¸  .service-versions.yaml not found, creating initial file...")
              initial_config = {
                  'default_version': version,
                  'services': {}
              }
              with open('.service-versions.yaml', 'w') as f:
                  f.write('# Service Version Tracking\n')
                  f.write('# This file tracks the last built version for each service\n')
                  f.write('# Updated automatically by build workflows\n')
                  f.write('# DO NOT EDIT MANUALLY\n\n')
                  yaml.dump(initial_config, f, default_flow_style=False, sort_keys=False)
              print("âœ… Initial .service-versions.yaml created")

          # Read current version tracking file
          with open('.service-versions.yaml', 'r') as f:
              version_config = yaml.safe_load(f)

          # Determine which services to update
          if services_input == 'all':
              # Update all buildable services
              with open('services.yaml', 'r') as f:
                  config = yaml.safe_load(f)
              services_to_update = [
                  svc['name'] for svc in config.get('services', [])
                  if svc.get('build', False)
              ]
          else:
              # Update only specified services
              services_to_update = [s.strip() for s in services_input.split(',')]

          # Update versions
          for service in services_to_update:
              if service in version_config['services']:
                  old_version = version_config['services'][service]
                  version_config['services'][service] = version
                  print(f"  {service}: {old_version} -> {version}")
              else:
                  version_config['services'][service] = version
                  print(f"  {service}: (new) -> {version}")

          # If updating all services, also update default version
          if services_input == 'all':
              version_config['default_version'] = version
              print(f"  default_version: -> {version}")

          # Write updated file
          with open('.service-versions.yaml', 'w') as f:
              f.write('# Service Version Tracking\n')
              f.write('# This file tracks the last built version for each service\n')
              f.write('# Updated automatically by build workflows\n')
              f.write('# DO NOT EDIT MANUALLY\n\n')
              yaml.dump(version_config, f, default_flow_style=False, sort_keys=False)

          print("\nâœ… Service versions updated")
          PYTHON_SCRIPT

      - name: Update source manifests with new image references
        run: |
          # Make script executable
          chmod +x .github/scripts/update-manifest-images.py

          # Get registry and version
          REGISTRY="${{ needs.prepare-matrix.outputs.registry }}"
          VERSION="${{ inputs.version }}"
          SERVICES_INPUT="${{ inputs.services }}"

          # Determine which services to update
          if [ "$SERVICES_INPUT" = "all" ]; then
            # Get all buildable services
            SERVICES_TO_UPDATE=$(python3 <<'PYTHON_SCRIPT'
          import yaml
          with open('services.yaml', 'r') as f:
              config = yaml.safe_load(f)
          services = [svc['name'] for svc in config.get('services', []) if svc.get('build', False)]
          print(' '.join(services))
          PYTHON_SCRIPT
          )
          else
            SERVICES_TO_UPDATE=$(echo "$SERVICES_INPUT" | tr ',' ' ')
          fi

          echo "Updating source manifests for: $SERVICES_TO_UPDATE"
          echo ""

          # Update each service's manifest
          for SERVICE in $SERVICES_TO_UPDATE; do
            # Determine image name (same logic as in prepare-matrix)
            case "$SERVICE" in
              accounting|ad|cart|fraud-detection|frontend|frontend-proxy|image-provider|llm|payment|product-reviews|recommendation)
                IMAGE_NAME="otel-${SERVICE}"
                ;;
              *)
                IMAGE_NAME="${SERVICE}"
                ;;
            esac

            # Update the manifest
            python3 .github/scripts/update-manifest-images.py "$SERVICE" "$REGISTRY" "$IMAGE_NAME" "$VERSION"
          done

          echo ""
          echo "âœ… Source manifests updated with new image references"

      - name: Commit manifest changes only
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Only add changed manifests (NOT .service-versions.yaml)
          # .service-versions.yaml stays local for tracking but is never committed
          git add src/*//*-k8s.yaml

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update test manifests to ${{ inputs.version }}" \
              -m "Services: ${{ inputs.services }}" \
              -m "" \
              -m "Updated:" \
              -m "- Source k8s manifests with new image references" \
              -m "" \
              -m "Note: .service-versions.yaml updated locally but not committed"
            git push
            echo "âœ… Manifests committed and pushed"
          fi

          echo "### ðŸ“ Service Versions and Manifests Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Updated services to version: \`${{ inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… .service-versions.yaml updated" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Source manifests updated with new image references" >> $GITHUB_STEP_SUMMARY

  trigger-manifest-build:
    needs: [prepare-matrix, build-images, update-service-versions]
    if: ${{ success() }}
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger manifest build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "### ðŸš€ Triggering Manifest Build" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Automatically building manifest with per-service versions..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Trigger the test manifest build workflow
          # Pass the version from build to ensure manifest filename matches
          gh workflow run test-build-manifest.yml \
            -f version="${{ inputs.version }}" \
            -f commit_manifest=true \
            -f validate_manifest=true

          echo "âœ… Manifest build workflow triggered" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Workflow | \`test-build-manifest.yml\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${{ inputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Version Source | \`.service-versions.yaml\` (per-service) |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`true\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Validate | \`true\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the [Actions tab](../../actions/workflows/test-build-manifest.yml) to monitor the manifest build." >> $GITHUB_STEP_SUMMARY

  summary:
    needs: [prepare-matrix, build-images, update-service-versions, trigger-manifest-build]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Build Summary
        run: |
          echo "## ðŸŽ‰ Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** \`${{ needs.prepare-matrix.outputs.registry }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Services:** ${{ inputs.services }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Automatic Actions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Manifest build triggered automatically" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“¦ Manifest will use version: \`${{ inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> The manifest build will automatically match your container image versions." >> $GITHUB_STEP_SUMMARY

name: Build Images - PRODUCTION
# NOTE: Repository check happens at job level, not at workflow level
# This workflow is designed for splunk/opentelemetry-demo repository only

"on":
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type (or use existing version)'
        required: true
        type: choice
        options:
          - none (keep current)
          - patch
          - minor
          - major
        default: 'minor'
      services:
        description: 'Services to build (comma-separated, or "all" for services with build:true)'
        required: false
        type: string
        default: 'all'
      no_cache:
        description: 'Disable build cache'
        required: false
        type: boolean
        default: false

jobs:
  determine-version:
    # Only run in the main splunk/opentelemetry-demo repo, not in forks
    # TEMPORARY: Commented out for testing in fork - UNCOMMENT BEFORE PR TO PROD
    if: github.repository == 'splunk/opentelemetry-demo'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Make scripts executable
        run: |
          chmod +x .github/scripts/bump-version.py
          chmod +x .github/scripts/manage-hotfix.py

      - name: Determine version
        id: version
        run: |
          CURRENT_VERSION=$(cat SPLUNK-VERSION)
          BUMP_TYPE="${{ inputs.version_bump }}"
          SERVICES="${{ inputs.services }}"

          echo "Current version: $CURRENT_VERSION"
          echo "Services to build: $SERVICES"

          # Determine if this is a hotfix build (single service, no full version bump)
          IS_HOTFIX="false"
          if [[ "$SERVICES" != "all" ]] && [[ "$BUMP_TYPE" == "none (keep current)" ]]; then
            IS_HOTFIX="true"
          fi

          # Calculate version
          if [[ "$IS_HOTFIX" == "true" ]]; then
            # Hotfix: use manage-hotfix.py to track and version
            SERVICE_NAME=$(echo "$SERVICES" | tr ',' '\n' | head -1 | xargs)
            VERSION=$(python3 .github/scripts/manage-hotfix.py add "$SERVICE_NAME")
            echo "Creating hotfix version for $SERVICE_NAME: $VERSION"
            VERSION_STATUS="hotfix"
          elif [[ "$BUMP_TYPE" == "none (keep current)" ]]; then
            # Keep current version
            VERSION="$CURRENT_VERSION"
            echo "Keeping current version: $VERSION"
            VERSION_STATUS="unchanged"
          else
            # Bump the version - this is a full release
            VERSION=$(python3 .github/scripts/bump-version.py "$CURRENT_VERSION" "$BUMP_TYPE")
            echo "Bumped version from $CURRENT_VERSION to $VERSION"
            VERSION_STATUS="bumped"
          fi

          # Determine if this is a full release
          IS_FULL_RELEASE="false"
          if [[ "$SERVICES" == "all" && "$VERSION_STATUS" == "bumped" ]]; then
            IS_FULL_RELEASE="true"
          fi

          # Output values
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_hotfix=$IS_HOTFIX" >> $GITHUB_OUTPUT
          echo "is_full_release=$IS_FULL_RELEASE" >> $GITHUB_OUTPUT

          # Debug output
          echo "DEBUG: version=$VERSION"
          echo "DEBUG: is_hotfix=$IS_HOTFIX"
          echo "DEBUG: is_full_release=$IS_FULL_RELEASE"
          echo "DEBUG: SERVICES=$SERVICES"
          echo "DEBUG: VERSION_STATUS=$VERSION_STATUS"

          echo "### Version Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Type | Version |" >> $GITHUB_STEP_SUMMARY
          echo "|------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Current | \`$CURRENT_VERSION\` |" >> $GITHUB_STEP_SUMMARY
          if [[ "$VERSION_STATUS" == "unchanged" ]]; then
            echo "| **Using** | **\`$VERSION\`** (unchanged) |" >> $GITHUB_STEP_SUMMARY
          elif [[ "$VERSION_STATUS" == "hotfix" ]]; then
            echo "| **Hotfix** | **\`$VERSION\`** |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| **New** | **\`$VERSION\`** |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| Action | ${{ inputs.version_bump }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Type | $([[ "$IS_HOTFIX" == "true" ]] && echo "Hotfix" || ([[ "$SERVICES" == "all" ]] && echo "Full Release" || echo "Partial")) |" >> $GITHUB_STEP_SUMMARY

          # Show hotfix status if applicable
          if [[ "$IS_HOTFIX" == "true" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### Hotfix Status" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            python3 .github/scripts/manage-hotfix.py status >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

  prepare-matrix:
    needs: determine-version
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      registry: ${{ steps.set-matrix.outputs.registry }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Generate build matrix
        id: set-matrix
        run: |
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import json
          import os

          # Read services.yaml
          with open('services.yaml', 'r') as f:
              config = yaml.safe_load(f)

          # Get production registry
          prod_registry = config.get('registry', {}).get('prod', 'ghcr.io/splunk/opentelemetry-demo')
          registry = prod_registry

          # Get services to build
          requested = "${{ inputs.services }}".strip()
          services_to_build = []

          for svc in config.get('services', []):
              name = svc.get('name')
              should_build = svc.get('build', False)

              if not should_build:
                  continue

              # Check if this service should be built
              if requested == 'all':
                  include = True
              else:
                  requested_list = [s.strip() for s in requested.split(',')]
                  include = name in requested_list

              if include:
                  # Get platform (default to multi-arch)
                  platform = svc.get('platform', 'linux/amd64,linux/arm64')

                  # Get dockerfile path (default to standard location)
                  dockerfile = svc.get('dockerfile', f'src/{name}/Dockerfile')

                  services_to_build.append({
                      'name': name,
                      'platform': platform,
                      'dockerfile': dockerfile
                  })

          # Create matrix - ensure at least a dummy entry to avoid GitHub Actions error
          if not services_to_build:
              # Add dummy entry that will be skipped
              matrix = {'include': [{'name': '_skip', 'platform': 'linux/amd64', 'dockerfile': 'none'}]}
          else:
              matrix = {'include': services_to_build}

          # Output to GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'matrix={json.dumps(matrix)}\n')
              f.write(f'registry={registry}\n')

          print(f"Registry: {registry}")
          print(f"Services to build: {len(services_to_build)}")
          if services_to_build:
              for svc in services_to_build:
                  print(f"  - {svc['name']} (platform: {svc['platform']})")
          else:
              print("  (none - dummy matrix entry added)")
          PYTHON_SCRIPT

      - name: Summary
        run: |
          echo "### Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ needs.determine-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** \`${{ steps.set-matrix.outputs.registry }}\` (production)" >> $GITHUB_STEP_SUMMARY
          echo "- **Services:** \`${{ inputs.services }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **No Cache:** ${{ inputs.no_cache }}" >> $GITHUB_STEP_SUMMARY

  build-images:
    needs: [determine-version, prepare-matrix]
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      packages: write

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
      - name: Check if this is a dummy run
        id: check-skip
        run: |
          if [[ "${{ matrix.name }}" == "_skip" ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "This is a dummy matrix entry - skipping all steps"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        if: steps.check-skip.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: steps.check-skip.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.check-skip.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Extract image name
        if: steps.check-skip.outputs.skip != 'true'
        id: image
        run: |
          SERVICE_NAME="${{ matrix.name }}"
          REGISTRY="${{ needs.prepare-matrix.outputs.registry }}"

          # All services use otel-{service} naming convention
          IMAGE_NAME="otel-${SERVICE_NAME}"

          FULL_IMAGE="${REGISTRY}/${IMAGE_NAME}:${{ needs.determine-version.outputs.version }}"

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT

          echo "Building: ${FULL_IMAGE}"

      - name: Check for Dockerfile
        if: steps.check-skip.outputs.skip != 'true'
        id: check
        run: |
          if [ -f "${{ matrix.dockerfile }}" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Dockerfile found: ${{ matrix.dockerfile }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Dockerfile not found: ${{ matrix.dockerfile }}"
          fi

      - name: Build and push image
        if: steps.check.outputs.exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.image.outputs.full_image }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ inputs.no_cache }}

      - name: Image info
        if: steps.check.outputs.exists == 'true'
        run: |
          echo "### âœ… Image Built: ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Service | \`${{ matrix.name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ steps.image.outputs.full_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | \`${{ matrix.platform }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Dockerfile | \`${{ matrix.dockerfile }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: Skip notice
        if: steps.check.outputs.exists == 'false'
        run: |
          echo "### âš ï¸ Skipped: ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Dockerfile not found at: \`${{ matrix.dockerfile }}\`" >> $GITHUB_STEP_SUMMARY

  update-versions:
    needs: [determine-version, prepare-matrix, build-images]
    # Only run in production repo, not forks
    if: ${{ success() && github.repository == 'splunk/opentelemetry-demo' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Make scripts executable
        run: |
          chmod +x .github/scripts/manage-hotfix.py
          chmod +x .github/scripts/update-manifest-images.py
          chmod +x .github/scripts/show-image-versions.py

      - name: Show current version state
        run: |
          echo "### ðŸ“Š Current Version State" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**SPLUNK-VERSION:** \`$(cat SPLUNK-VERSION)\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Update SPLUNK-VERSION on version bump
        if: ${{ needs.determine-version.outputs.is_hotfix == 'false' && inputs.version_bump != 'none (keep current)' }}
        run: |
          CURRENT=$(cat SPLUNK-VERSION)
          NEW="${{ needs.determine-version.outputs.version }}"

          echo "$NEW" > SPLUNK-VERSION
          echo "âœ… SPLUNK-VERSION updated: $CURRENT â†’ $NEW"

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”¼ Version Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Type | Version |" >> $GITHUB_STEP_SUMMARY
          echo "|------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Previous | \`$CURRENT\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **New** | **\`$NEW\`** |" >> $GITHUB_STEP_SUMMARY
          echo "| Bump Type | ${{ inputs.version_bump }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Clear hotfixes on full releases
        if: ${{ needs.determine-version.outputs.is_full_release == 'true' }}
        run: |
          python3 .github/scripts/manage-hotfix.py clear
          echo "âœ… Hotfixes cleared for full release"

      - name: Update source manifests with new image references
        run: |
          # Get registry and version
          REGISTRY="${{ needs.prepare-matrix.outputs.registry }}"
          VERSION="${{ needs.determine-version.outputs.version }}"
          SERVICES_INPUT="${{ inputs.services }}"

          # Determine which services to update
          if [ "$SERVICES_INPUT" = "all" ]; then
            # Get all buildable services
            SERVICES_TO_UPDATE=$(python3 <<'PYTHON_SCRIPT'
          import yaml
          with open('services.yaml', 'r') as f:
              config = yaml.safe_load(f)
          services = [svc['name'] for svc in config.get('services', []) if svc.get('build', False)]
          print(' '.join(services))
          PYTHON_SCRIPT
          )
          else
            SERVICES_TO_UPDATE=$(echo "$SERVICES_INPUT" | tr ',' ' ')
          fi

          echo "Updating source manifests for: $SERVICES_TO_UPDATE"
          echo ""

          # Update each service's manifest
          for SERVICE in $SERVICES_TO_UPDATE; do
            # All services use otel-{service} naming convention
            IMAGE_NAME="otel-${SERVICE}"

            # Update the manifest
            python3 .github/scripts/update-manifest-images.py "$SERVICE" "$REGISTRY" "$IMAGE_NAME" "$VERSION"
          done

          echo ""
          echo "âœ… Source manifests updated with new image references"
          echo ""
          echo "â„¹ï¸  Manifest stitching can be done separately using the 'Build Demo Manifest - PRODUCTION' workflow"

      - name: Show image version breakdown
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Image Versions After Build" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Services built this run: \`${{ inputs.services }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show version breakdown
          python3 .github/scripts/show-image-versions.py \
            --base-version "${{ needs.determine-version.outputs.version }}" \
            --format github >> $GITHUB_STEP_SUMMARY

      - name: Create Pull Request with image build changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          VERSION="${{ needs.determine-version.outputs.version }}"
          IS_HOTFIX="${{ needs.determine-version.outputs.is_hotfix }}"
          IS_FULL_RELEASE="${{ needs.determine-version.outputs.is_full_release }}"
          SERVICES="${{ inputs.services }}"
          BRANCH_NAME="release/images-${VERSION}"

          # For hotfixes, commit .hotfix.yaml
          if [[ "$IS_HOTFIX" == "true" ]]; then
            git add .hotfix.yaml
          fi

          # For version bumps (not hotfixes), commit SPLUNK-VERSION
          if [[ "$IS_HOTFIX" == "false" && "${{ inputs.version_bump }}" != "none (keep current)" ]]; then
            git add SPLUNK-VERSION
          fi

          # For full releases, clear hotfixes
          if [[ "$IS_FULL_RELEASE" == "true" ]]; then
            # Stage deletion of .hotfix.yaml if it was removed
            if ! [ -f .hotfix.yaml ]; then
              git rm --ignore-unmatch .hotfix.yaml 2>/dev/null || true
            fi
          fi

          # Always add updated source manifests
          git add src/*//*-k8s.yaml

          if git diff --staged --quiet; then
            echo "No version changes to commit"
          else
            # Create and checkout new branch
            git checkout -b "$BRANCH_NAME"

            # Determine commit message and PR title
            if [[ "$IS_HOTFIX" == "true" ]]; then
              COMMIT_TITLE="chore: hotfix build ${VERSION}"
              PR_TITLE="Hotfix Build: ${VERSION}"
              git commit -m "$COMMIT_TITLE" \
                -m "Service: ${SERVICES}" \
                -m "" \
                -m "Hotfix applied to service on base version $(cat SPLUNK-VERSION)" \
                -m "" \
                -m "Updated:" \
                -m "- .hotfix.yaml" \
                -m "- Source k8s manifests with new image references"

              # Build PR body with variable expansion using printf to avoid YAML parsing issues
              PR_BODY=$(printf '%s\n' \
                "## Hotfix Build" \
                "" \
                "**Version:** \`${VERSION}\`" \
                "**Service:** ${SERVICES}" \
                "**Base Version:** \`$(cat SPLUNK-VERSION)\`" \
                "" \
                "### Changes" \
                "- âœ… .hotfix.yaml updated" \
                "- âœ… Source k8s manifests updated with new image references" \
                "" \
                "### Next Steps" \
                "Run the **Build Demo Manifest - PRODUCTION** workflow to stitch the manifest." \
                "" \
                "---" \
                "ðŸ¤– Generated automatically by GitHub Actions"
              )

            elif [[ "$IS_FULL_RELEASE" == "true" ]]; then
              COMMIT_TITLE="chore: release version ${VERSION}"
              PR_TITLE="Release ${VERSION}"
              git commit -m "$COMMIT_TITLE" \
                -m "Version bump: ${{ inputs.version_bump }}" \
                -m "All services updated to version ${VERSION}" \
                -m "All hotfixes cleared" \
                -m "" \
                -m "Updated:" \
                -m "- SPLUNK-VERSION" \
                -m "- Source k8s manifests with new image references"

              # Build PR body with variable expansion using printf to avoid YAML parsing issues
              PR_BODY=$(printf '%s\n' \
                "## Release ${VERSION}" \
                "" \
                "**Version Bump:** ${{ inputs.version_bump }}" \
                "**Services:** All services updated" \
                "" \
                "### Changes" \
                "- âœ… SPLUNK-VERSION updated to \`${VERSION}\`" \
                "- âœ… All hotfixes cleared" \
                "- âœ… Source k8s manifests updated with new image references" \
                "" \
                "### Next Steps" \
                "Run the **Build Demo Manifest - PRODUCTION** workflow to stitch the manifest." \
                "" \
                "---" \
                "ðŸ¤– Generated automatically by GitHub Actions"
              )

            else
              # Partial build with version bump
              COMMIT_TITLE="chore: production build ${VERSION}"
              PR_TITLE="Production Build: ${VERSION}"

              # Check if version was bumped
              if [[ "${{ inputs.version_bump }}" != "none (keep current)" ]]; then
                git commit -m "$COMMIT_TITLE" \
                  -m "Version bump: ${{ inputs.version_bump }}" \
                  -m "Services: ${SERVICES}" \
                  -m "" \
                  -m "Updated:" \
                  -m "- SPLUNK-VERSION" \
                  -m "- Source k8s manifests with new image references"

                # Build PR body with variable expansion using printf to avoid YAML parsing issues
                PR_BODY=$(printf '%s\n' \
                  "## Production Build ${VERSION}" \
                  "" \
                  "**Version Bump:** ${{ inputs.version_bump }}" \
                  "**Services Built:** ${SERVICES}" \
                  "" \
                  "### Changes" \
                  "- âœ… SPLUNK-VERSION updated to \`${VERSION}\`" \
                  "- âœ… Source k8s manifests updated with new image references" \
                  "" \
                  "### Note" \
                  "This is a partial build. Other services will use their existing image versions." \
                  "" \
                  "### Next Steps" \
                  "Run the **Build Demo Manifest - PRODUCTION** workflow to stitch the manifest." \
                  "" \
                  "---" \
                  "ðŸ¤– Generated automatically by GitHub Actions"
                )
              else
                git commit -m "$COMMIT_TITLE" \
                  -m "Services: ${SERVICES}" \
                  -m "" \
                  -m "Updated:" \
                  -m "- Source k8s manifests with new image references"

                # Build PR body with variable expansion using printf to avoid YAML parsing issues
                PR_BODY=$(printf '%s\n' \
                  "## Production Build ${VERSION}" \
                  "" \
                  "**Services:** ${SERVICES}" \
                  "" \
                  "### Changes" \
                  "- âœ… Source k8s manifests updated with new image references" \
                  "" \
                  "### Next Steps" \
                  "Run the **Build Demo Manifest - PRODUCTION** workflow to stitch the manifest." \
                  "" \
                  "---" \
                  "ðŸ¤– Generated automatically by GitHub Actions"
                )
              fi
            fi

            # Delete remote branch if it exists (from previous failed runs)
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || true

            # Push branch
            git push -u origin "$BRANCH_NAME"

            # Create pull request
            gh pr create \
              --title "$PR_TITLE" \
              --body "$PR_BODY" \
              --base main \
              --head "$BRANCH_NAME"

            PR_URL=$(gh pr view "$BRANCH_NAME" --json url -q .url)

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Pull Request Created âœ…" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**PR:** [$PR_TITLE]($PR_URL)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Branch:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ‘‰ **Review and merge the PR to apply changes**" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### ðŸ“ Version and Manifest Updates" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Updated to version: \`${{ needs.determine-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Source k8s manifests updated with new image references" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.determine-version.outputs.is_hotfix }}" == "true" ]]; then
            echo "- âœ… .hotfix.yaml updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Note:** Hotfix build. Base version: \`$(cat SPLUNK-VERSION)\`, Hotfix: \`${{ needs.determine-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.determine-version.outputs.is_full_release }}" == "true" ]]; then
            echo "- âœ… SPLUNK-VERSION updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Note:** Full release with unified version for all services" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Note:** Production builds use SPLUNK-VERSION for unified versioning. Hotfixes tracked separately in .hotfix.yaml" >> $GITHUB_STEP_SUMMARY
          fi

  summary:
    needs: [determine-version, prepare-matrix, build-images, update-versions]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Build Summary
        run: |
          echo "## ðŸŽ‰ Production Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ needs.determine-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version Bump:** ${{ inputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** \`${{ needs.prepare-matrix.outputs.registry }}\` (production)" >> $GITHUB_STEP_SUMMARY
          echo "- **Services:** ${{ inputs.services }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Automatic Actions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Production manifest build triggered automatically" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“¦ Manifest will use version: \`${{ needs.determine-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ­ Images published to production registry" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> The production manifest build will automatically match your container image versions." >> $GITHUB_STEP_SUMMARY

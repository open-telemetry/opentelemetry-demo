// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: demo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_demo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_demo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_demo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_demo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_demo_2eproto;
namespace oteldemo {
class Ad;
struct AdDefaultTypeInternal;
extern AdDefaultTypeInternal _Ad_default_instance_;
class AdRequest;
struct AdRequestDefaultTypeInternal;
extern AdRequestDefaultTypeInternal _AdRequest_default_instance_;
class AdResponse;
struct AdResponseDefaultTypeInternal;
extern AdResponseDefaultTypeInternal _AdResponse_default_instance_;
class AddItemRequest;
struct AddItemRequestDefaultTypeInternal;
extern AddItemRequestDefaultTypeInternal _AddItemRequest_default_instance_;
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class AskProductAIAssistantRequest;
struct AskProductAIAssistantRequestDefaultTypeInternal;
extern AskProductAIAssistantRequestDefaultTypeInternal _AskProductAIAssistantRequest_default_instance_;
class AskProductAIAssistantResponse;
struct AskProductAIAssistantResponseDefaultTypeInternal;
extern AskProductAIAssistantResponseDefaultTypeInternal _AskProductAIAssistantResponse_default_instance_;
class Cart;
struct CartDefaultTypeInternal;
extern CartDefaultTypeInternal _Cart_default_instance_;
class CartItem;
struct CartItemDefaultTypeInternal;
extern CartItemDefaultTypeInternal _CartItem_default_instance_;
class ChargeRequest;
struct ChargeRequestDefaultTypeInternal;
extern ChargeRequestDefaultTypeInternal _ChargeRequest_default_instance_;
class ChargeResponse;
struct ChargeResponseDefaultTypeInternal;
extern ChargeResponseDefaultTypeInternal _ChargeResponse_default_instance_;
class CreateFlagRequest;
struct CreateFlagRequestDefaultTypeInternal;
extern CreateFlagRequestDefaultTypeInternal _CreateFlagRequest_default_instance_;
class CreateFlagResponse;
struct CreateFlagResponseDefaultTypeInternal;
extern CreateFlagResponseDefaultTypeInternal _CreateFlagResponse_default_instance_;
class CreditCardInfo;
struct CreditCardInfoDefaultTypeInternal;
extern CreditCardInfoDefaultTypeInternal _CreditCardInfo_default_instance_;
class CurrencyConversionRequest;
struct CurrencyConversionRequestDefaultTypeInternal;
extern CurrencyConversionRequestDefaultTypeInternal _CurrencyConversionRequest_default_instance_;
class DeleteFlagRequest;
struct DeleteFlagRequestDefaultTypeInternal;
extern DeleteFlagRequestDefaultTypeInternal _DeleteFlagRequest_default_instance_;
class DeleteFlagResponse;
struct DeleteFlagResponseDefaultTypeInternal;
extern DeleteFlagResponseDefaultTypeInternal _DeleteFlagResponse_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class EmptyCartRequest;
struct EmptyCartRequestDefaultTypeInternal;
extern EmptyCartRequestDefaultTypeInternal _EmptyCartRequest_default_instance_;
class Flag;
struct FlagDefaultTypeInternal;
extern FlagDefaultTypeInternal _Flag_default_instance_;
class GetAverageProductReviewScoreRequest;
struct GetAverageProductReviewScoreRequestDefaultTypeInternal;
extern GetAverageProductReviewScoreRequestDefaultTypeInternal _GetAverageProductReviewScoreRequest_default_instance_;
class GetAverageProductReviewScoreResponse;
struct GetAverageProductReviewScoreResponseDefaultTypeInternal;
extern GetAverageProductReviewScoreResponseDefaultTypeInternal _GetAverageProductReviewScoreResponse_default_instance_;
class GetCartRequest;
struct GetCartRequestDefaultTypeInternal;
extern GetCartRequestDefaultTypeInternal _GetCartRequest_default_instance_;
class GetFlagRequest;
struct GetFlagRequestDefaultTypeInternal;
extern GetFlagRequestDefaultTypeInternal _GetFlagRequest_default_instance_;
class GetFlagResponse;
struct GetFlagResponseDefaultTypeInternal;
extern GetFlagResponseDefaultTypeInternal _GetFlagResponse_default_instance_;
class GetProductRequest;
struct GetProductRequestDefaultTypeInternal;
extern GetProductRequestDefaultTypeInternal _GetProductRequest_default_instance_;
class GetProductReviewsRequest;
struct GetProductReviewsRequestDefaultTypeInternal;
extern GetProductReviewsRequestDefaultTypeInternal _GetProductReviewsRequest_default_instance_;
class GetProductReviewsResponse;
struct GetProductReviewsResponseDefaultTypeInternal;
extern GetProductReviewsResponseDefaultTypeInternal _GetProductReviewsResponse_default_instance_;
class GetQuoteRequest;
struct GetQuoteRequestDefaultTypeInternal;
extern GetQuoteRequestDefaultTypeInternal _GetQuoteRequest_default_instance_;
class GetQuoteResponse;
struct GetQuoteResponseDefaultTypeInternal;
extern GetQuoteResponseDefaultTypeInternal _GetQuoteResponse_default_instance_;
class GetSupportedCurrenciesResponse;
struct GetSupportedCurrenciesResponseDefaultTypeInternal;
extern GetSupportedCurrenciesResponseDefaultTypeInternal _GetSupportedCurrenciesResponse_default_instance_;
class ListFlagsRequest;
struct ListFlagsRequestDefaultTypeInternal;
extern ListFlagsRequestDefaultTypeInternal _ListFlagsRequest_default_instance_;
class ListFlagsResponse;
struct ListFlagsResponseDefaultTypeInternal;
extern ListFlagsResponseDefaultTypeInternal _ListFlagsResponse_default_instance_;
class ListProductsResponse;
struct ListProductsResponseDefaultTypeInternal;
extern ListProductsResponseDefaultTypeInternal _ListProductsResponse_default_instance_;
class ListRecommendationsRequest;
struct ListRecommendationsRequestDefaultTypeInternal;
extern ListRecommendationsRequestDefaultTypeInternal _ListRecommendationsRequest_default_instance_;
class ListRecommendationsResponse;
struct ListRecommendationsResponseDefaultTypeInternal;
extern ListRecommendationsResponseDefaultTypeInternal _ListRecommendationsResponse_default_instance_;
class Money;
struct MoneyDefaultTypeInternal;
extern MoneyDefaultTypeInternal _Money_default_instance_;
class OrderItem;
struct OrderItemDefaultTypeInternal;
extern OrderItemDefaultTypeInternal _OrderItem_default_instance_;
class OrderResult;
struct OrderResultDefaultTypeInternal;
extern OrderResultDefaultTypeInternal _OrderResult_default_instance_;
class PlaceOrderRequest;
struct PlaceOrderRequestDefaultTypeInternal;
extern PlaceOrderRequestDefaultTypeInternal _PlaceOrderRequest_default_instance_;
class PlaceOrderResponse;
struct PlaceOrderResponseDefaultTypeInternal;
extern PlaceOrderResponseDefaultTypeInternal _PlaceOrderResponse_default_instance_;
class Product;
struct ProductDefaultTypeInternal;
extern ProductDefaultTypeInternal _Product_default_instance_;
class ProductReview;
struct ProductReviewDefaultTypeInternal;
extern ProductReviewDefaultTypeInternal _ProductReview_default_instance_;
class SearchProductsRequest;
struct SearchProductsRequestDefaultTypeInternal;
extern SearchProductsRequestDefaultTypeInternal _SearchProductsRequest_default_instance_;
class SearchProductsResponse;
struct SearchProductsResponseDefaultTypeInternal;
extern SearchProductsResponseDefaultTypeInternal _SearchProductsResponse_default_instance_;
class SendOrderConfirmationRequest;
struct SendOrderConfirmationRequestDefaultTypeInternal;
extern SendOrderConfirmationRequestDefaultTypeInternal _SendOrderConfirmationRequest_default_instance_;
class ShipOrderRequest;
struct ShipOrderRequestDefaultTypeInternal;
extern ShipOrderRequestDefaultTypeInternal _ShipOrderRequest_default_instance_;
class ShipOrderResponse;
struct ShipOrderResponseDefaultTypeInternal;
extern ShipOrderResponseDefaultTypeInternal _ShipOrderResponse_default_instance_;
class UpdateFlagRequest;
struct UpdateFlagRequestDefaultTypeInternal;
extern UpdateFlagRequestDefaultTypeInternal _UpdateFlagRequest_default_instance_;
class UpdateFlagResponse;
struct UpdateFlagResponseDefaultTypeInternal;
extern UpdateFlagResponseDefaultTypeInternal _UpdateFlagResponse_default_instance_;
}  // namespace oteldemo
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace oteldemo {

// ===================================================================


// -------------------------------------------------------------------

class CartItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.CartItem) */ {
 public:
  inline CartItem() : CartItem(nullptr) {}
  ~CartItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CartItem(::google::protobuf::internal::ConstantInitialized);

  CartItem(const CartItem& from);
  CartItem(CartItem&& from) noexcept
    : CartItem() {
    *this = ::std::move(from);
  }

  inline CartItem& operator=(const CartItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartItem& operator=(CartItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartItem* internal_default_instance() {
    return reinterpret_cast<const CartItem*>(
               &_CartItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CartItem& a, CartItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CartItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CartItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CartItem& from) {
    CartItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.CartItem";
  }
  protected:
  explicit CartItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // string product_id = 1;
  void clear_product_id() ;
  const std::string& product_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_product_id(Arg_&& arg, Args_... args);
  std::string* mutable_product_id();
  PROTOBUF_NODISCARD std::string* release_product_id();
  void set_allocated_product_id(std::string* ptr);

  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(
      const std::string& value);
  std::string* _internal_mutable_product_id();

  public:
  // int32 quantity = 2;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.CartItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr product_id_;
    ::int32_t quantity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class AddItemRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.AddItemRequest) */ {
 public:
  inline AddItemRequest() : AddItemRequest(nullptr) {}
  ~AddItemRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddItemRequest(::google::protobuf::internal::ConstantInitialized);

  AddItemRequest(const AddItemRequest& from);
  AddItemRequest(AddItemRequest&& from) noexcept
    : AddItemRequest() {
    *this = ::std::move(from);
  }

  inline AddItemRequest& operator=(const AddItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddItemRequest& operator=(AddItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddItemRequest* internal_default_instance() {
    return reinterpret_cast<const AddItemRequest*>(
               &_AddItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddItemRequest& a, AddItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddItemRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddItemRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddItemRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddItemRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddItemRequest& from) {
    AddItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddItemRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.AddItemRequest";
  }
  protected:
  explicit AddItemRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kItemFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* ptr);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // .oteldemo.CartItem item = 2;
  bool has_item() const;
  void clear_item() ;
  const ::oteldemo::CartItem& item() const;
  PROTOBUF_NODISCARD ::oteldemo::CartItem* release_item();
  ::oteldemo::CartItem* mutable_item();
  void set_allocated_item(::oteldemo::CartItem* value);
  void unsafe_arena_set_allocated_item(::oteldemo::CartItem* value);
  ::oteldemo::CartItem* unsafe_arena_release_item();

  private:
  const ::oteldemo::CartItem& _internal_item() const;
  ::oteldemo::CartItem* _internal_mutable_item();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.AddItemRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::oteldemo::CartItem* item_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class EmptyCartRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.EmptyCartRequest) */ {
 public:
  inline EmptyCartRequest() : EmptyCartRequest(nullptr) {}
  ~EmptyCartRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyCartRequest(::google::protobuf::internal::ConstantInitialized);

  EmptyCartRequest(const EmptyCartRequest& from);
  EmptyCartRequest(EmptyCartRequest&& from) noexcept
    : EmptyCartRequest() {
    *this = ::std::move(from);
  }

  inline EmptyCartRequest& operator=(const EmptyCartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyCartRequest& operator=(EmptyCartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyCartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyCartRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyCartRequest*>(
               &_EmptyCartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EmptyCartRequest& a, EmptyCartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyCartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyCartRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyCartRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyCartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmptyCartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EmptyCartRequest& from) {
    EmptyCartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyCartRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.EmptyCartRequest";
  }
  protected:
  explicit EmptyCartRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* ptr);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.EmptyCartRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 41, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetCartRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetCartRequest) */ {
 public:
  inline GetCartRequest() : GetCartRequest(nullptr) {}
  ~GetCartRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCartRequest(::google::protobuf::internal::ConstantInitialized);

  GetCartRequest(const GetCartRequest& from);
  GetCartRequest(GetCartRequest&& from) noexcept
    : GetCartRequest() {
    *this = ::std::move(from);
  }

  inline GetCartRequest& operator=(const GetCartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCartRequest& operator=(GetCartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCartRequest* internal_default_instance() {
    return reinterpret_cast<const GetCartRequest*>(
               &_GetCartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetCartRequest& a, GetCartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCartRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCartRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetCartRequest& from) {
    GetCartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCartRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetCartRequest";
  }
  protected:
  explicit GetCartRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* ptr);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetCartRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Cart final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.Cart) */ {
 public:
  inline Cart() : Cart(nullptr) {}
  ~Cart() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cart(::google::protobuf::internal::ConstantInitialized);

  Cart(const Cart& from);
  Cart(Cart&& from) noexcept
    : Cart() {
    *this = ::std::move(from);
  }

  inline Cart& operator=(const Cart& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cart& operator=(Cart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cart& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cart* internal_default_instance() {
    return reinterpret_cast<const Cart*>(
               &_Cart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Cart& a, Cart& b) {
    a.Swap(&b);
  }
  inline void Swap(Cart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cart* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cart* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cart>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Cart& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Cart& from) {
    Cart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cart* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Cart";
  }
  protected:
  explicit Cart(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .oteldemo.CartItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::oteldemo::CartItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>* _internal_mutable_items();
  public:
  const ::oteldemo::CartItem& items(int index) const;
  ::oteldemo::CartItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >&
      items() const;
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* ptr);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.Cart)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 29, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem > items_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Empty final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(::google::protobuf::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Empty";
  }
  protected:
  explicit Empty(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ListRecommendationsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListRecommendationsRequest) */ {
 public:
  inline ListRecommendationsRequest() : ListRecommendationsRequest(nullptr) {}
  ~ListRecommendationsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListRecommendationsRequest(::google::protobuf::internal::ConstantInitialized);

  ListRecommendationsRequest(const ListRecommendationsRequest& from);
  ListRecommendationsRequest(ListRecommendationsRequest&& from) noexcept
    : ListRecommendationsRequest() {
    *this = ::std::move(from);
  }

  inline ListRecommendationsRequest& operator=(const ListRecommendationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRecommendationsRequest& operator=(ListRecommendationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRecommendationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRecommendationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRecommendationsRequest*>(
               &_ListRecommendationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListRecommendationsRequest& a, ListRecommendationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRecommendationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRecommendationsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRecommendationsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRecommendationsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRecommendationsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListRecommendationsRequest& from) {
    ListRecommendationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRecommendationsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ListRecommendationsRequest";
  }
  protected:
  explicit ListRecommendationsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated string product_ids = 2;
  int product_ids_size() const;
  private:
  int _internal_product_ids_size() const;

  public:
  void clear_product_ids() ;
  const std::string& product_ids(int index) const;
  std::string* mutable_product_ids(int index);
  void set_product_ids(int index, const std::string& value);
  void set_product_ids(int index, std::string&& value);
  void set_product_ids(int index, const char* value);
  void set_product_ids(int index, const char* value, std::size_t size);
  void set_product_ids(int index, absl::string_view value);
  std::string* add_product_ids();
  void add_product_ids(const std::string& value);
  void add_product_ids(std::string&& value);
  void add_product_ids(const char* value);
  void add_product_ids(const char* value, std::size_t size);
  void add_product_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& product_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_product_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_product_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_product_ids();

  public:
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* ptr);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ListRecommendationsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 62, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> product_ids_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ListRecommendationsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListRecommendationsResponse) */ {
 public:
  inline ListRecommendationsResponse() : ListRecommendationsResponse(nullptr) {}
  ~ListRecommendationsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListRecommendationsResponse(::google::protobuf::internal::ConstantInitialized);

  ListRecommendationsResponse(const ListRecommendationsResponse& from);
  ListRecommendationsResponse(ListRecommendationsResponse&& from) noexcept
    : ListRecommendationsResponse() {
    *this = ::std::move(from);
  }

  inline ListRecommendationsResponse& operator=(const ListRecommendationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRecommendationsResponse& operator=(ListRecommendationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRecommendationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRecommendationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRecommendationsResponse*>(
               &_ListRecommendationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListRecommendationsResponse& a, ListRecommendationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRecommendationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRecommendationsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRecommendationsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRecommendationsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRecommendationsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListRecommendationsResponse& from) {
    ListRecommendationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRecommendationsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ListRecommendationsResponse";
  }
  protected:
  explicit ListRecommendationsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdsFieldNumber = 1,
  };
  // repeated string product_ids = 1;
  int product_ids_size() const;
  private:
  int _internal_product_ids_size() const;

  public:
  void clear_product_ids() ;
  const std::string& product_ids(int index) const;
  std::string* mutable_product_ids(int index);
  void set_product_ids(int index, const std::string& value);
  void set_product_ids(int index, std::string&& value);
  void set_product_ids(int index, const char* value);
  void set_product_ids(int index, const char* value, std::size_t size);
  void set_product_ids(int index, absl::string_view value);
  std::string* add_product_ids();
  void add_product_ids(const std::string& value);
  void add_product_ids(std::string&& value);
  void add_product_ids(const char* value);
  void add_product_ids(const char* value, std::size_t size);
  void add_product_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& product_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_product_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_product_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_product_ids();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ListRecommendationsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 56, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> product_ids_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Product final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.Product) */ {
 public:
  inline Product() : Product(nullptr) {}
  ~Product() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Product(::google::protobuf::internal::ConstantInitialized);

  Product(const Product& from);
  Product(Product&& from) noexcept
    : Product() {
    *this = ::std::move(from);
  }

  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  inline Product& operator=(Product&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Product& default_instance() {
    return *internal_default_instance();
  }
  static inline const Product* internal_default_instance() {
    return reinterpret_cast<const Product*>(
               &_Product_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Product& a, Product& b) {
    a.Swap(&b);
  }
  inline void Swap(Product* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Product* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Product* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Product>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Product& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Product& from) {
    Product::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Product* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Product";
  }
  protected:
  explicit Product(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kPictureFieldNumber = 4,
    kPriceUsdFieldNumber = 5,
  };
  // repeated string categories = 6;
  int categories_size() const;
  private:
  int _internal_categories_size() const;

  public:
  void clear_categories() ;
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, std::size_t size);
  void set_categories(int index, absl::string_view value);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, std::size_t size);
  void add_categories(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& categories() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_categories();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_categories() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_categories();

  public:
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 3;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string picture = 4;
  void clear_picture() ;
  const std::string& picture() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_picture(Arg_&& arg, Args_... args);
  std::string* mutable_picture();
  PROTOBUF_NODISCARD std::string* release_picture();
  void set_allocated_picture(std::string* ptr);

  private:
  const std::string& _internal_picture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picture(
      const std::string& value);
  std::string* _internal_mutable_picture();

  public:
  // .oteldemo.Money price_usd = 5;
  bool has_price_usd() const;
  void clear_price_usd() ;
  const ::oteldemo::Money& price_usd() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_price_usd();
  ::oteldemo::Money* mutable_price_usd();
  void set_allocated_price_usd(::oteldemo::Money* value);
  void unsafe_arena_set_allocated_price_usd(::oteldemo::Money* value);
  ::oteldemo::Money* unsafe_arena_release_price_usd();

  private:
  const ::oteldemo::Money& _internal_price_usd() const;
  ::oteldemo::Money* _internal_mutable_price_usd();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.Product)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> categories_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr picture_;
    ::oteldemo::Money* price_usd_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ListProductsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListProductsResponse) */ {
 public:
  inline ListProductsResponse() : ListProductsResponse(nullptr) {}
  ~ListProductsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListProductsResponse(::google::protobuf::internal::ConstantInitialized);

  ListProductsResponse(const ListProductsResponse& from);
  ListProductsResponse(ListProductsResponse&& from) noexcept
    : ListProductsResponse() {
    *this = ::std::move(from);
  }

  inline ListProductsResponse& operator=(const ListProductsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProductsResponse& operator=(ListProductsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProductsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProductsResponse* internal_default_instance() {
    return reinterpret_cast<const ListProductsResponse*>(
               &_ListProductsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListProductsResponse& a, ListProductsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProductsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProductsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListProductsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListProductsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListProductsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListProductsResponse& from) {
    ListProductsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProductsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ListProductsResponse";
  }
  protected:
  explicit ListProductsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductsFieldNumber = 1,
  };
  // repeated .oteldemo.Product products = 1;
  int products_size() const;
  private:
  int _internal_products_size() const;

  public:
  void clear_products() ;
  ::oteldemo::Product* mutable_products(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >*
      mutable_products();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::Product>& _internal_products() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::Product>* _internal_mutable_products();
  public:
  const ::oteldemo::Product& products(int index) const;
  ::oteldemo::Product* add_products();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >&
      products() const;
  // @@protoc_insertion_point(class_scope:oteldemo.ListProductsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::oteldemo::Product > products_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetProductRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetProductRequest) */ {
 public:
  inline GetProductRequest() : GetProductRequest(nullptr) {}
  ~GetProductRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProductRequest(::google::protobuf::internal::ConstantInitialized);

  GetProductRequest(const GetProductRequest& from);
  GetProductRequest(GetProductRequest&& from) noexcept
    : GetProductRequest() {
    *this = ::std::move(from);
  }

  inline GetProductRequest& operator=(const GetProductRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProductRequest& operator=(GetProductRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProductRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProductRequest* internal_default_instance() {
    return reinterpret_cast<const GetProductRequest*>(
               &_GetProductRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetProductRequest& a, GetProductRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProductRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProductRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProductRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProductRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProductRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProductRequest& from) {
    GetProductRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProductRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetProductRequest";
  }
  protected:
  explicit GetProductRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetProductRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 37, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class SearchProductsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.SearchProductsRequest) */ {
 public:
  inline SearchProductsRequest() : SearchProductsRequest(nullptr) {}
  ~SearchProductsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchProductsRequest(::google::protobuf::internal::ConstantInitialized);

  SearchProductsRequest(const SearchProductsRequest& from);
  SearchProductsRequest(SearchProductsRequest&& from) noexcept
    : SearchProductsRequest() {
    *this = ::std::move(from);
  }

  inline SearchProductsRequest& operator=(const SearchProductsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchProductsRequest& operator=(SearchProductsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchProductsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchProductsRequest* internal_default_instance() {
    return reinterpret_cast<const SearchProductsRequest*>(
               &_SearchProductsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SearchProductsRequest& a, SearchProductsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchProductsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchProductsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchProductsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchProductsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchProductsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SearchProductsRequest& from) {
    SearchProductsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchProductsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.SearchProductsRequest";
  }
  protected:
  explicit SearchProductsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
  };
  // string query = 1;
  void clear_query() ;
  const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* ptr);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.SearchProductsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr query_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class SearchProductsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.SearchProductsResponse) */ {
 public:
  inline SearchProductsResponse() : SearchProductsResponse(nullptr) {}
  ~SearchProductsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchProductsResponse(::google::protobuf::internal::ConstantInitialized);

  SearchProductsResponse(const SearchProductsResponse& from);
  SearchProductsResponse(SearchProductsResponse&& from) noexcept
    : SearchProductsResponse() {
    *this = ::std::move(from);
  }

  inline SearchProductsResponse& operator=(const SearchProductsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchProductsResponse& operator=(SearchProductsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchProductsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchProductsResponse* internal_default_instance() {
    return reinterpret_cast<const SearchProductsResponse*>(
               &_SearchProductsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SearchProductsResponse& a, SearchProductsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchProductsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchProductsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchProductsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchProductsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchProductsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SearchProductsResponse& from) {
    SearchProductsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchProductsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.SearchProductsResponse";
  }
  protected:
  explicit SearchProductsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .oteldemo.Product results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  ::oteldemo::Product* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::Product>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::Product>* _internal_mutable_results();
  public:
  const ::oteldemo::Product& results(int index) const;
  ::oteldemo::Product* add_results();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >&
      results() const;
  // @@protoc_insertion_point(class_scope:oteldemo.SearchProductsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::oteldemo::Product > results_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ProductReview final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ProductReview) */ {
 public:
  inline ProductReview() : ProductReview(nullptr) {}
  ~ProductReview() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProductReview(::google::protobuf::internal::ConstantInitialized);

  ProductReview(const ProductReview& from);
  ProductReview(ProductReview&& from) noexcept
    : ProductReview() {
    *this = ::std::move(from);
  }

  inline ProductReview& operator=(const ProductReview& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductReview& operator=(ProductReview&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductReview& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductReview* internal_default_instance() {
    return reinterpret_cast<const ProductReview*>(
               &_ProductReview_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProductReview& a, ProductReview& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductReview* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductReview* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductReview* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductReview>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProductReview& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProductReview& from) {
    ProductReview::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductReview* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ProductReview";
  }
  protected:
  explicit ProductReview(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* ptr);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string score = 3;
  void clear_score() ;
  const std::string& score() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_score(Arg_&& arg, Args_... args);
  std::string* mutable_score();
  PROTOBUF_NODISCARD std::string* release_score();
  void set_allocated_score(std::string* ptr);

  private:
  const std::string& _internal_score() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_score(
      const std::string& value);
  std::string* _internal_mutable_score();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ProductReview)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 55, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr score_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetProductReviewsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetProductReviewsRequest) */ {
 public:
  inline GetProductReviewsRequest() : GetProductReviewsRequest(nullptr) {}
  ~GetProductReviewsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProductReviewsRequest(::google::protobuf::internal::ConstantInitialized);

  GetProductReviewsRequest(const GetProductReviewsRequest& from);
  GetProductReviewsRequest(GetProductReviewsRequest&& from) noexcept
    : GetProductReviewsRequest() {
    *this = ::std::move(from);
  }

  inline GetProductReviewsRequest& operator=(const GetProductReviewsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProductReviewsRequest& operator=(GetProductReviewsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProductReviewsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProductReviewsRequest* internal_default_instance() {
    return reinterpret_cast<const GetProductReviewsRequest*>(
               &_GetProductReviewsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetProductReviewsRequest& a, GetProductReviewsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProductReviewsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProductReviewsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProductReviewsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProductReviewsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProductReviewsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProductReviewsRequest& from) {
    GetProductReviewsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProductReviewsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetProductReviewsRequest";
  }
  protected:
  explicit GetProductReviewsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
  };
  // string product_id = 1;
  void clear_product_id() ;
  const std::string& product_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_product_id(Arg_&& arg, Args_... args);
  std::string* mutable_product_id();
  PROTOBUF_NODISCARD std::string* release_product_id();
  void set_allocated_product_id(std::string* ptr);

  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(
      const std::string& value);
  std::string* _internal_mutable_product_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetProductReviewsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr product_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetProductReviewsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetProductReviewsResponse) */ {
 public:
  inline GetProductReviewsResponse() : GetProductReviewsResponse(nullptr) {}
  ~GetProductReviewsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProductReviewsResponse(::google::protobuf::internal::ConstantInitialized);

  GetProductReviewsResponse(const GetProductReviewsResponse& from);
  GetProductReviewsResponse(GetProductReviewsResponse&& from) noexcept
    : GetProductReviewsResponse() {
    *this = ::std::move(from);
  }

  inline GetProductReviewsResponse& operator=(const GetProductReviewsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProductReviewsResponse& operator=(GetProductReviewsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProductReviewsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProductReviewsResponse* internal_default_instance() {
    return reinterpret_cast<const GetProductReviewsResponse*>(
               &_GetProductReviewsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetProductReviewsResponse& a, GetProductReviewsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProductReviewsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProductReviewsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProductReviewsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProductReviewsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProductReviewsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetProductReviewsResponse& from) {
    GetProductReviewsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProductReviewsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetProductReviewsResponse";
  }
  protected:
  explicit GetProductReviewsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductReviewsFieldNumber = 1,
  };
  // repeated .oteldemo.ProductReview product_reviews = 1;
  int product_reviews_size() const;
  private:
  int _internal_product_reviews_size() const;

  public:
  void clear_product_reviews() ;
  ::oteldemo::ProductReview* mutable_product_reviews(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::ProductReview >*
      mutable_product_reviews();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::ProductReview>& _internal_product_reviews() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::ProductReview>* _internal_mutable_product_reviews();
  public:
  const ::oteldemo::ProductReview& product_reviews(int index) const;
  ::oteldemo::ProductReview* add_product_reviews();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::ProductReview >&
      product_reviews() const;
  // @@protoc_insertion_point(class_scope:oteldemo.GetProductReviewsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::oteldemo::ProductReview > product_reviews_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetAverageProductReviewScoreRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetAverageProductReviewScoreRequest) */ {
 public:
  inline GetAverageProductReviewScoreRequest() : GetAverageProductReviewScoreRequest(nullptr) {}
  ~GetAverageProductReviewScoreRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAverageProductReviewScoreRequest(::google::protobuf::internal::ConstantInitialized);

  GetAverageProductReviewScoreRequest(const GetAverageProductReviewScoreRequest& from);
  GetAverageProductReviewScoreRequest(GetAverageProductReviewScoreRequest&& from) noexcept
    : GetAverageProductReviewScoreRequest() {
    *this = ::std::move(from);
  }

  inline GetAverageProductReviewScoreRequest& operator=(const GetAverageProductReviewScoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAverageProductReviewScoreRequest& operator=(GetAverageProductReviewScoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAverageProductReviewScoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAverageProductReviewScoreRequest* internal_default_instance() {
    return reinterpret_cast<const GetAverageProductReviewScoreRequest*>(
               &_GetAverageProductReviewScoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetAverageProductReviewScoreRequest& a, GetAverageProductReviewScoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAverageProductReviewScoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAverageProductReviewScoreRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAverageProductReviewScoreRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAverageProductReviewScoreRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAverageProductReviewScoreRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAverageProductReviewScoreRequest& from) {
    GetAverageProductReviewScoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAverageProductReviewScoreRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetAverageProductReviewScoreRequest";
  }
  protected:
  explicit GetAverageProductReviewScoreRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
  };
  // string product_id = 1;
  void clear_product_id() ;
  const std::string& product_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_product_id(Arg_&& arg, Args_... args);
  std::string* mutable_product_id();
  PROTOBUF_NODISCARD std::string* release_product_id();
  void set_allocated_product_id(std::string* ptr);

  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(
      const std::string& value);
  std::string* _internal_mutable_product_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetAverageProductReviewScoreRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 63, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr product_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetAverageProductReviewScoreResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetAverageProductReviewScoreResponse) */ {
 public:
  inline GetAverageProductReviewScoreResponse() : GetAverageProductReviewScoreResponse(nullptr) {}
  ~GetAverageProductReviewScoreResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAverageProductReviewScoreResponse(::google::protobuf::internal::ConstantInitialized);

  GetAverageProductReviewScoreResponse(const GetAverageProductReviewScoreResponse& from);
  GetAverageProductReviewScoreResponse(GetAverageProductReviewScoreResponse&& from) noexcept
    : GetAverageProductReviewScoreResponse() {
    *this = ::std::move(from);
  }

  inline GetAverageProductReviewScoreResponse& operator=(const GetAverageProductReviewScoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAverageProductReviewScoreResponse& operator=(GetAverageProductReviewScoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAverageProductReviewScoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAverageProductReviewScoreResponse* internal_default_instance() {
    return reinterpret_cast<const GetAverageProductReviewScoreResponse*>(
               &_GetAverageProductReviewScoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetAverageProductReviewScoreResponse& a, GetAverageProductReviewScoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAverageProductReviewScoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAverageProductReviewScoreResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAverageProductReviewScoreResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAverageProductReviewScoreResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAverageProductReviewScoreResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAverageProductReviewScoreResponse& from) {
    GetAverageProductReviewScoreResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAverageProductReviewScoreResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetAverageProductReviewScoreResponse";
  }
  protected:
  explicit GetAverageProductReviewScoreResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAverageScoreFieldNumber = 1,
  };
  // string average_score = 1;
  void clear_average_score() ;
  const std::string& average_score() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_average_score(Arg_&& arg, Args_... args);
  std::string* mutable_average_score();
  PROTOBUF_NODISCARD std::string* release_average_score();
  void set_allocated_average_score(std::string* ptr);

  private:
  const std::string& _internal_average_score() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_average_score(
      const std::string& value);
  std::string* _internal_mutable_average_score();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetAverageProductReviewScoreResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 67, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr average_score_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class AskProductAIAssistantRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.AskProductAIAssistantRequest) */ {
 public:
  inline AskProductAIAssistantRequest() : AskProductAIAssistantRequest(nullptr) {}
  ~AskProductAIAssistantRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AskProductAIAssistantRequest(::google::protobuf::internal::ConstantInitialized);

  AskProductAIAssistantRequest(const AskProductAIAssistantRequest& from);
  AskProductAIAssistantRequest(AskProductAIAssistantRequest&& from) noexcept
    : AskProductAIAssistantRequest() {
    *this = ::std::move(from);
  }

  inline AskProductAIAssistantRequest& operator=(const AskProductAIAssistantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskProductAIAssistantRequest& operator=(AskProductAIAssistantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskProductAIAssistantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskProductAIAssistantRequest* internal_default_instance() {
    return reinterpret_cast<const AskProductAIAssistantRequest*>(
               &_AskProductAIAssistantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AskProductAIAssistantRequest& a, AskProductAIAssistantRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AskProductAIAssistantRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskProductAIAssistantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskProductAIAssistantRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskProductAIAssistantRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskProductAIAssistantRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AskProductAIAssistantRequest& from) {
    AskProductAIAssistantRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskProductAIAssistantRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.AskProductAIAssistantRequest";
  }
  protected:
  explicit AskProductAIAssistantRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
    kQuestionFieldNumber = 2,
  };
  // string product_id = 1;
  void clear_product_id() ;
  const std::string& product_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_product_id(Arg_&& arg, Args_... args);
  std::string* mutable_product_id();
  PROTOBUF_NODISCARD std::string* release_product_id();
  void set_allocated_product_id(std::string* ptr);

  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(
      const std::string& value);
  std::string* _internal_mutable_product_id();

  public:
  // string question = 2;
  void clear_question() ;
  const std::string& question() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_question(Arg_&& arg, Args_... args);
  std::string* mutable_question();
  PROTOBUF_NODISCARD std::string* release_question();
  void set_allocated_question(std::string* ptr);

  private:
  const std::string& _internal_question() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_question(
      const std::string& value);
  std::string* _internal_mutable_question();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.AskProductAIAssistantRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 64, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr product_id_;
    ::google::protobuf::internal::ArenaStringPtr question_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class AskProductAIAssistantResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.AskProductAIAssistantResponse) */ {
 public:
  inline AskProductAIAssistantResponse() : AskProductAIAssistantResponse(nullptr) {}
  ~AskProductAIAssistantResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AskProductAIAssistantResponse(::google::protobuf::internal::ConstantInitialized);

  AskProductAIAssistantResponse(const AskProductAIAssistantResponse& from);
  AskProductAIAssistantResponse(AskProductAIAssistantResponse&& from) noexcept
    : AskProductAIAssistantResponse() {
    *this = ::std::move(from);
  }

  inline AskProductAIAssistantResponse& operator=(const AskProductAIAssistantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskProductAIAssistantResponse& operator=(AskProductAIAssistantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskProductAIAssistantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskProductAIAssistantResponse* internal_default_instance() {
    return reinterpret_cast<const AskProductAIAssistantResponse*>(
               &_AskProductAIAssistantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AskProductAIAssistantResponse& a, AskProductAIAssistantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AskProductAIAssistantResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskProductAIAssistantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskProductAIAssistantResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskProductAIAssistantResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskProductAIAssistantResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AskProductAIAssistantResponse& from) {
    AskProductAIAssistantResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskProductAIAssistantResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.AskProductAIAssistantResponse";
  }
  protected:
  explicit AskProductAIAssistantResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.AskProductAIAssistantResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 55, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr response_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetQuoteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetQuoteRequest) */ {
 public:
  inline GetQuoteRequest() : GetQuoteRequest(nullptr) {}
  ~GetQuoteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetQuoteRequest(::google::protobuf::internal::ConstantInitialized);

  GetQuoteRequest(const GetQuoteRequest& from);
  GetQuoteRequest(GetQuoteRequest&& from) noexcept
    : GetQuoteRequest() {
    *this = ::std::move(from);
  }

  inline GetQuoteRequest& operator=(const GetQuoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuoteRequest& operator=(GetQuoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuoteRequest* internal_default_instance() {
    return reinterpret_cast<const GetQuoteRequest*>(
               &_GetQuoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetQuoteRequest& a, GetQuoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQuoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuoteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuoteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQuoteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetQuoteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetQuoteRequest& from) {
    GetQuoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQuoteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetQuoteRequest";
  }
  protected:
  explicit GetQuoteRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // repeated .oteldemo.CartItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::oteldemo::CartItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>* _internal_mutable_items();
  public:
  const ::oteldemo::CartItem& items(int index) const;
  ::oteldemo::CartItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >&
      items() const;
  // .oteldemo.Address address = 1;
  bool has_address() const;
  void clear_address() ;
  const ::oteldemo::Address& address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_address();
  ::oteldemo::Address* mutable_address();
  void set_allocated_address(::oteldemo::Address* value);
  void unsafe_arena_set_allocated_address(::oteldemo::Address* value);
  ::oteldemo::Address* unsafe_arena_release_address();

  private:
  const ::oteldemo::Address& _internal_address() const;
  ::oteldemo::Address* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetQuoteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem > items_;
    ::oteldemo::Address* address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetQuoteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetQuoteResponse) */ {
 public:
  inline GetQuoteResponse() : GetQuoteResponse(nullptr) {}
  ~GetQuoteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetQuoteResponse(::google::protobuf::internal::ConstantInitialized);

  GetQuoteResponse(const GetQuoteResponse& from);
  GetQuoteResponse(GetQuoteResponse&& from) noexcept
    : GetQuoteResponse() {
    *this = ::std::move(from);
  }

  inline GetQuoteResponse& operator=(const GetQuoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuoteResponse& operator=(GetQuoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuoteResponse* internal_default_instance() {
    return reinterpret_cast<const GetQuoteResponse*>(
               &_GetQuoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetQuoteResponse& a, GetQuoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQuoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuoteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuoteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQuoteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetQuoteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetQuoteResponse& from) {
    GetQuoteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQuoteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetQuoteResponse";
  }
  protected:
  explicit GetQuoteResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCostUsdFieldNumber = 1,
  };
  // .oteldemo.Money cost_usd = 1;
  bool has_cost_usd() const;
  void clear_cost_usd() ;
  const ::oteldemo::Money& cost_usd() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_cost_usd();
  ::oteldemo::Money* mutable_cost_usd();
  void set_allocated_cost_usd(::oteldemo::Money* value);
  void unsafe_arena_set_allocated_cost_usd(::oteldemo::Money* value);
  ::oteldemo::Money* unsafe_arena_release_cost_usd();

  private:
  const ::oteldemo::Money& _internal_cost_usd() const;
  ::oteldemo::Money* _internal_mutable_cost_usd();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetQuoteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::oteldemo::Money* cost_usd_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ShipOrderRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ShipOrderRequest) */ {
 public:
  inline ShipOrderRequest() : ShipOrderRequest(nullptr) {}
  ~ShipOrderRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShipOrderRequest(::google::protobuf::internal::ConstantInitialized);

  ShipOrderRequest(const ShipOrderRequest& from);
  ShipOrderRequest(ShipOrderRequest&& from) noexcept
    : ShipOrderRequest() {
    *this = ::std::move(from);
  }

  inline ShipOrderRequest& operator=(const ShipOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShipOrderRequest& operator=(ShipOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShipOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShipOrderRequest* internal_default_instance() {
    return reinterpret_cast<const ShipOrderRequest*>(
               &_ShipOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ShipOrderRequest& a, ShipOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShipOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShipOrderRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShipOrderRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShipOrderRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShipOrderRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShipOrderRequest& from) {
    ShipOrderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShipOrderRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ShipOrderRequest";
  }
  protected:
  explicit ShipOrderRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // repeated .oteldemo.CartItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::oteldemo::CartItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>* _internal_mutable_items();
  public:
  const ::oteldemo::CartItem& items(int index) const;
  ::oteldemo::CartItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >&
      items() const;
  // .oteldemo.Address address = 1;
  bool has_address() const;
  void clear_address() ;
  const ::oteldemo::Address& address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_address();
  ::oteldemo::Address* mutable_address();
  void set_allocated_address(::oteldemo::Address* value);
  void unsafe_arena_set_allocated_address(::oteldemo::Address* value);
  ::oteldemo::Address* unsafe_arena_release_address();

  private:
  const ::oteldemo::Address& _internal_address() const;
  ::oteldemo::Address* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ShipOrderRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem > items_;
    ::oteldemo::Address* address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ShipOrderResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ShipOrderResponse) */ {
 public:
  inline ShipOrderResponse() : ShipOrderResponse(nullptr) {}
  ~ShipOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShipOrderResponse(::google::protobuf::internal::ConstantInitialized);

  ShipOrderResponse(const ShipOrderResponse& from);
  ShipOrderResponse(ShipOrderResponse&& from) noexcept
    : ShipOrderResponse() {
    *this = ::std::move(from);
  }

  inline ShipOrderResponse& operator=(const ShipOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShipOrderResponse& operator=(ShipOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShipOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShipOrderResponse* internal_default_instance() {
    return reinterpret_cast<const ShipOrderResponse*>(
               &_ShipOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ShipOrderResponse& a, ShipOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShipOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShipOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShipOrderResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShipOrderResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShipOrderResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShipOrderResponse& from) {
    ShipOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShipOrderResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ShipOrderResponse";
  }
  protected:
  explicit ShipOrderResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackingIdFieldNumber = 1,
  };
  // string tracking_id = 1;
  void clear_tracking_id() ;
  const std::string& tracking_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tracking_id(Arg_&& arg, Args_... args);
  std::string* mutable_tracking_id();
  PROTOBUF_NODISCARD std::string* release_tracking_id();
  void set_allocated_tracking_id(std::string* ptr);

  private:
  const std::string& _internal_tracking_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tracking_id(
      const std::string& value);
  std::string* _internal_mutable_tracking_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ShipOrderResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr tracking_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Address final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Address(::google::protobuf::internal::ConstantInitialized);

  Address(const Address& from);
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }
  inline void Swap(Address* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Address* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Address>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Address& from) {
    Address::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Address* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Address";
  }
  protected:
  explicit Address(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreetAddressFieldNumber = 1,
    kCityFieldNumber = 2,
    kStateFieldNumber = 3,
    kCountryFieldNumber = 4,
    kZipCodeFieldNumber = 5,
  };
  // string street_address = 1;
  void clear_street_address() ;
  const std::string& street_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_street_address(Arg_&& arg, Args_... args);
  std::string* mutable_street_address();
  PROTOBUF_NODISCARD std::string* release_street_address();
  void set_allocated_street_address(std::string* ptr);

  private:
  const std::string& _internal_street_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street_address(
      const std::string& value);
  std::string* _internal_mutable_street_address();

  public:
  // string city = 2;
  void clear_city() ;
  const std::string& city() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_city(Arg_&& arg, Args_... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* ptr);

  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(
      const std::string& value);
  std::string* _internal_mutable_city();

  public:
  // string state = 3;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string country = 4;
  void clear_country() ;
  const std::string& country() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country(Arg_&& arg, Args_... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* ptr);

  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(
      const std::string& value);
  std::string* _internal_mutable_country();

  public:
  // string zip_code = 5;
  void clear_zip_code() ;
  const std::string& zip_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zip_code(Arg_&& arg, Args_... args);
  std::string* mutable_zip_code();
  PROTOBUF_NODISCARD std::string* release_zip_code();
  void set_allocated_zip_code(std::string* ptr);

  private:
  const std::string& _internal_zip_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zip_code(
      const std::string& value);
  std::string* _internal_mutable_zip_code();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.Address)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 63, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr street_address_;
    ::google::protobuf::internal::ArenaStringPtr city_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::google::protobuf::internal::ArenaStringPtr country_;
    ::google::protobuf::internal::ArenaStringPtr zip_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Money final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.Money) */ {
 public:
  inline Money() : Money(nullptr) {}
  ~Money() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Money(::google::protobuf::internal::ConstantInitialized);

  Money(const Money& from);
  Money(Money&& from) noexcept
    : Money() {
    *this = ::std::move(from);
  }

  inline Money& operator=(const Money& from) {
    CopyFrom(from);
    return *this;
  }
  inline Money& operator=(Money&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Money& default_instance() {
    return *internal_default_instance();
  }
  static inline const Money* internal_default_instance() {
    return reinterpret_cast<const Money*>(
               &_Money_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Money& a, Money& b) {
    a.Swap(&b);
  }
  inline void Swap(Money* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Money* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Money* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Money>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Money& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Money& from) {
    Money::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Money* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Money";
  }
  protected:
  explicit Money(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kNanosFieldNumber = 3,
  };
  // string currency_code = 1;
  void clear_currency_code() ;
  const std::string& currency_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_currency_code(Arg_&& arg, Args_... args);
  std::string* mutable_currency_code();
  PROTOBUF_NODISCARD std::string* release_currency_code();
  void set_allocated_currency_code(std::string* ptr);

  private:
  const std::string& _internal_currency_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency_code(
      const std::string& value);
  std::string* _internal_mutable_currency_code();

  public:
  // int64 units = 2;
  void clear_units() ;
  ::int64_t units() const;
  void set_units(::int64_t value);

  private:
  ::int64_t _internal_units() const;
  void _internal_set_units(::int64_t value);

  public:
  // int32 nanos = 3;
  void clear_nanos() ;
  ::int32_t nanos() const;
  void set_nanos(::int32_t value);

  private:
  ::int32_t _internal_nanos() const;
  void _internal_set_nanos(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.Money)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr currency_code_;
    ::int64_t units_;
    ::int32_t nanos_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetSupportedCurrenciesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetSupportedCurrenciesResponse) */ {
 public:
  inline GetSupportedCurrenciesResponse() : GetSupportedCurrenciesResponse(nullptr) {}
  ~GetSupportedCurrenciesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSupportedCurrenciesResponse(::google::protobuf::internal::ConstantInitialized);

  GetSupportedCurrenciesResponse(const GetSupportedCurrenciesResponse& from);
  GetSupportedCurrenciesResponse(GetSupportedCurrenciesResponse&& from) noexcept
    : GetSupportedCurrenciesResponse() {
    *this = ::std::move(from);
  }

  inline GetSupportedCurrenciesResponse& operator=(const GetSupportedCurrenciesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSupportedCurrenciesResponse& operator=(GetSupportedCurrenciesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSupportedCurrenciesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSupportedCurrenciesResponse* internal_default_instance() {
    return reinterpret_cast<const GetSupportedCurrenciesResponse*>(
               &_GetSupportedCurrenciesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetSupportedCurrenciesResponse& a, GetSupportedCurrenciesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSupportedCurrenciesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSupportedCurrenciesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSupportedCurrenciesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSupportedCurrenciesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSupportedCurrenciesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetSupportedCurrenciesResponse& from) {
    GetSupportedCurrenciesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSupportedCurrenciesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetSupportedCurrenciesResponse";
  }
  protected:
  explicit GetSupportedCurrenciesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodesFieldNumber = 1,
  };
  // repeated string currency_codes = 1;
  int currency_codes_size() const;
  private:
  int _internal_currency_codes_size() const;

  public:
  void clear_currency_codes() ;
  const std::string& currency_codes(int index) const;
  std::string* mutable_currency_codes(int index);
  void set_currency_codes(int index, const std::string& value);
  void set_currency_codes(int index, std::string&& value);
  void set_currency_codes(int index, const char* value);
  void set_currency_codes(int index, const char* value, std::size_t size);
  void set_currency_codes(int index, absl::string_view value);
  std::string* add_currency_codes();
  void add_currency_codes(const std::string& value);
  void add_currency_codes(std::string&& value);
  void add_currency_codes(const char* value);
  void add_currency_codes(const char* value, std::size_t size);
  void add_currency_codes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& currency_codes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_currency_codes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_currency_codes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_currency_codes();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetSupportedCurrenciesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 62, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> currency_codes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class CurrencyConversionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.CurrencyConversionRequest) */ {
 public:
  inline CurrencyConversionRequest() : CurrencyConversionRequest(nullptr) {}
  ~CurrencyConversionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CurrencyConversionRequest(::google::protobuf::internal::ConstantInitialized);

  CurrencyConversionRequest(const CurrencyConversionRequest& from);
  CurrencyConversionRequest(CurrencyConversionRequest&& from) noexcept
    : CurrencyConversionRequest() {
    *this = ::std::move(from);
  }

  inline CurrencyConversionRequest& operator=(const CurrencyConversionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyConversionRequest& operator=(CurrencyConversionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyConversionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyConversionRequest* internal_default_instance() {
    return reinterpret_cast<const CurrencyConversionRequest*>(
               &_CurrencyConversionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CurrencyConversionRequest& a, CurrencyConversionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyConversionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyConversionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyConversionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyConversionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurrencyConversionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CurrencyConversionRequest& from) {
    CurrencyConversionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyConversionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.CurrencyConversionRequest";
  }
  protected:
  explicit CurrencyConversionRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToCodeFieldNumber = 2,
    kFromFieldNumber = 1,
  };
  // string to_code = 2;
  void clear_to_code() ;
  const std::string& to_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to_code(Arg_&& arg, Args_... args);
  std::string* mutable_to_code();
  PROTOBUF_NODISCARD std::string* release_to_code();
  void set_allocated_to_code(std::string* ptr);

  private:
  const std::string& _internal_to_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_code(
      const std::string& value);
  std::string* _internal_mutable_to_code();

  public:
  // .oteldemo.Money from = 1;
  bool has_from() const;
  void clear_from() ;
  const ::oteldemo::Money& from() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_from();
  ::oteldemo::Money* mutable_from();
  void set_allocated_from(::oteldemo::Money* value);
  void unsafe_arena_set_allocated_from(::oteldemo::Money* value);
  ::oteldemo::Money* unsafe_arena_release_from();

  private:
  const ::oteldemo::Money& _internal_from() const;
  ::oteldemo::Money* _internal_mutable_from();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.CurrencyConversionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr to_code_;
    ::oteldemo::Money* from_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class CreditCardInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.CreditCardInfo) */ {
 public:
  inline CreditCardInfo() : CreditCardInfo(nullptr) {}
  ~CreditCardInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreditCardInfo(::google::protobuf::internal::ConstantInitialized);

  CreditCardInfo(const CreditCardInfo& from);
  CreditCardInfo(CreditCardInfo&& from) noexcept
    : CreditCardInfo() {
    *this = ::std::move(from);
  }

  inline CreditCardInfo& operator=(const CreditCardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreditCardInfo& operator=(CreditCardInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreditCardInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreditCardInfo* internal_default_instance() {
    return reinterpret_cast<const CreditCardInfo*>(
               &_CreditCardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreditCardInfo& a, CreditCardInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CreditCardInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreditCardInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreditCardInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreditCardInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreditCardInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreditCardInfo& from) {
    CreditCardInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreditCardInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.CreditCardInfo";
  }
  protected:
  explicit CreditCardInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreditCardNumberFieldNumber = 1,
    kCreditCardCvvFieldNumber = 2,
    kCreditCardExpirationYearFieldNumber = 3,
    kCreditCardExpirationMonthFieldNumber = 4,
  };
  // string credit_card_number = 1;
  void clear_credit_card_number() ;
  const std::string& credit_card_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_credit_card_number(Arg_&& arg, Args_... args);
  std::string* mutable_credit_card_number();
  PROTOBUF_NODISCARD std::string* release_credit_card_number();
  void set_allocated_credit_card_number(std::string* ptr);

  private:
  const std::string& _internal_credit_card_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credit_card_number(
      const std::string& value);
  std::string* _internal_mutable_credit_card_number();

  public:
  // int32 credit_card_cvv = 2;
  void clear_credit_card_cvv() ;
  ::int32_t credit_card_cvv() const;
  void set_credit_card_cvv(::int32_t value);

  private:
  ::int32_t _internal_credit_card_cvv() const;
  void _internal_set_credit_card_cvv(::int32_t value);

  public:
  // int32 credit_card_expiration_year = 3;
  void clear_credit_card_expiration_year() ;
  ::int32_t credit_card_expiration_year() const;
  void set_credit_card_expiration_year(::int32_t value);

  private:
  ::int32_t _internal_credit_card_expiration_year() const;
  void _internal_set_credit_card_expiration_year(::int32_t value);

  public:
  // int32 credit_card_expiration_month = 4;
  void clear_credit_card_expiration_month() ;
  ::int32_t credit_card_expiration_month() const;
  void set_credit_card_expiration_month(::int32_t value);

  private:
  ::int32_t _internal_credit_card_expiration_month() const;
  void _internal_set_credit_card_expiration_month(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.CreditCardInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr credit_card_number_;
    ::int32_t credit_card_cvv_;
    ::int32_t credit_card_expiration_year_;
    ::int32_t credit_card_expiration_month_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ChargeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ChargeRequest) */ {
 public:
  inline ChargeRequest() : ChargeRequest(nullptr) {}
  ~ChargeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChargeRequest(::google::protobuf::internal::ConstantInitialized);

  ChargeRequest(const ChargeRequest& from);
  ChargeRequest(ChargeRequest&& from) noexcept
    : ChargeRequest() {
    *this = ::std::move(from);
  }

  inline ChargeRequest& operator=(const ChargeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChargeRequest& operator=(ChargeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChargeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChargeRequest* internal_default_instance() {
    return reinterpret_cast<const ChargeRequest*>(
               &_ChargeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ChargeRequest& a, ChargeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChargeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChargeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChargeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChargeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChargeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChargeRequest& from) {
    ChargeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChargeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ChargeRequest";
  }
  protected:
  explicit ChargeRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
    kCreditCardFieldNumber = 2,
  };
  // .oteldemo.Money amount = 1;
  bool has_amount() const;
  void clear_amount() ;
  const ::oteldemo::Money& amount() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_amount();
  ::oteldemo::Money* mutable_amount();
  void set_allocated_amount(::oteldemo::Money* value);
  void unsafe_arena_set_allocated_amount(::oteldemo::Money* value);
  ::oteldemo::Money* unsafe_arena_release_amount();

  private:
  const ::oteldemo::Money& _internal_amount() const;
  ::oteldemo::Money* _internal_mutable_amount();

  public:
  // .oteldemo.CreditCardInfo credit_card = 2;
  bool has_credit_card() const;
  void clear_credit_card() ;
  const ::oteldemo::CreditCardInfo& credit_card() const;
  PROTOBUF_NODISCARD ::oteldemo::CreditCardInfo* release_credit_card();
  ::oteldemo::CreditCardInfo* mutable_credit_card();
  void set_allocated_credit_card(::oteldemo::CreditCardInfo* value);
  void unsafe_arena_set_allocated_credit_card(::oteldemo::CreditCardInfo* value);
  ::oteldemo::CreditCardInfo* unsafe_arena_release_credit_card();

  private:
  const ::oteldemo::CreditCardInfo& _internal_credit_card() const;
  ::oteldemo::CreditCardInfo* _internal_mutable_credit_card();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ChargeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::oteldemo::Money* amount_;
    ::oteldemo::CreditCardInfo* credit_card_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ChargeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ChargeResponse) */ {
 public:
  inline ChargeResponse() : ChargeResponse(nullptr) {}
  ~ChargeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChargeResponse(::google::protobuf::internal::ConstantInitialized);

  ChargeResponse(const ChargeResponse& from);
  ChargeResponse(ChargeResponse&& from) noexcept
    : ChargeResponse() {
    *this = ::std::move(from);
  }

  inline ChargeResponse& operator=(const ChargeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChargeResponse& operator=(ChargeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChargeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChargeResponse* internal_default_instance() {
    return reinterpret_cast<const ChargeResponse*>(
               &_ChargeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ChargeResponse& a, ChargeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChargeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChargeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChargeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChargeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChargeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChargeResponse& from) {
    ChargeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChargeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ChargeResponse";
  }
  protected:
  explicit ChargeResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 1,
  };
  // string transaction_id = 1;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* ptr);

  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(
      const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.ChargeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class OrderItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.OrderItem) */ {
 public:
  inline OrderItem() : OrderItem(nullptr) {}
  ~OrderItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderItem(::google::protobuf::internal::ConstantInitialized);

  OrderItem(const OrderItem& from);
  OrderItem(OrderItem&& from) noexcept
    : OrderItem() {
    *this = ::std::move(from);
  }

  inline OrderItem& operator=(const OrderItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderItem& operator=(OrderItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderItem* internal_default_instance() {
    return reinterpret_cast<const OrderItem*>(
               &_OrderItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(OrderItem& a, OrderItem& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OrderItem& from) {
    OrderItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.OrderItem";
  }
  protected:
  explicit OrderItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // .oteldemo.CartItem item = 1;
  bool has_item() const;
  void clear_item() ;
  const ::oteldemo::CartItem& item() const;
  PROTOBUF_NODISCARD ::oteldemo::CartItem* release_item();
  ::oteldemo::CartItem* mutable_item();
  void set_allocated_item(::oteldemo::CartItem* value);
  void unsafe_arena_set_allocated_item(::oteldemo::CartItem* value);
  ::oteldemo::CartItem* unsafe_arena_release_item();

  private:
  const ::oteldemo::CartItem& _internal_item() const;
  ::oteldemo::CartItem* _internal_mutable_item();

  public:
  // .oteldemo.Money cost = 2;
  bool has_cost() const;
  void clear_cost() ;
  const ::oteldemo::Money& cost() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_cost();
  ::oteldemo::Money* mutable_cost();
  void set_allocated_cost(::oteldemo::Money* value);
  void unsafe_arena_set_allocated_cost(::oteldemo::Money* value);
  ::oteldemo::Money* unsafe_arena_release_cost();

  private:
  const ::oteldemo::Money& _internal_cost() const;
  ::oteldemo::Money* _internal_mutable_cost();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.OrderItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::oteldemo::CartItem* item_;
    ::oteldemo::Money* cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class OrderResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.OrderResult) */ {
 public:
  inline OrderResult() : OrderResult(nullptr) {}
  ~OrderResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderResult(::google::protobuf::internal::ConstantInitialized);

  OrderResult(const OrderResult& from);
  OrderResult(OrderResult&& from) noexcept
    : OrderResult() {
    *this = ::std::move(from);
  }

  inline OrderResult& operator=(const OrderResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderResult& operator=(OrderResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderResult* internal_default_instance() {
    return reinterpret_cast<const OrderResult*>(
               &_OrderResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(OrderResult& a, OrderResult& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OrderResult& from) {
    OrderResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.OrderResult";
  }
  protected:
  explicit OrderResult(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 5,
    kOrderIdFieldNumber = 1,
    kShippingTrackingIdFieldNumber = 2,
    kShippingCostFieldNumber = 3,
    kShippingAddressFieldNumber = 4,
  };
  // repeated .oteldemo.OrderItem items = 5;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::oteldemo::OrderItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::OrderItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::OrderItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::OrderItem>* _internal_mutable_items();
  public:
  const ::oteldemo::OrderItem& items(int index) const;
  ::oteldemo::OrderItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::OrderItem >&
      items() const;
  // string order_id = 1;
  void clear_order_id() ;
  const std::string& order_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_id(Arg_&& arg, Args_... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* ptr);

  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(
      const std::string& value);
  std::string* _internal_mutable_order_id();

  public:
  // string shipping_tracking_id = 2;
  void clear_shipping_tracking_id() ;
  const std::string& shipping_tracking_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shipping_tracking_id(Arg_&& arg, Args_... args);
  std::string* mutable_shipping_tracking_id();
  PROTOBUF_NODISCARD std::string* release_shipping_tracking_id();
  void set_allocated_shipping_tracking_id(std::string* ptr);

  private:
  const std::string& _internal_shipping_tracking_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shipping_tracking_id(
      const std::string& value);
  std::string* _internal_mutable_shipping_tracking_id();

  public:
  // .oteldemo.Money shipping_cost = 3;
  bool has_shipping_cost() const;
  void clear_shipping_cost() ;
  const ::oteldemo::Money& shipping_cost() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_shipping_cost();
  ::oteldemo::Money* mutable_shipping_cost();
  void set_allocated_shipping_cost(::oteldemo::Money* value);
  void unsafe_arena_set_allocated_shipping_cost(::oteldemo::Money* value);
  ::oteldemo::Money* unsafe_arena_release_shipping_cost();

  private:
  const ::oteldemo::Money& _internal_shipping_cost() const;
  ::oteldemo::Money* _internal_mutable_shipping_cost();

  public:
  // .oteldemo.Address shipping_address = 4;
  bool has_shipping_address() const;
  void clear_shipping_address() ;
  const ::oteldemo::Address& shipping_address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_shipping_address();
  ::oteldemo::Address* mutable_shipping_address();
  void set_allocated_shipping_address(::oteldemo::Address* value);
  void unsafe_arena_set_allocated_shipping_address(::oteldemo::Address* value);
  ::oteldemo::Address* unsafe_arena_release_shipping_address();

  private:
  const ::oteldemo::Address& _internal_shipping_address() const;
  ::oteldemo::Address* _internal_mutable_shipping_address();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.OrderResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 3, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::oteldemo::OrderItem > items_;
    ::google::protobuf::internal::ArenaStringPtr order_id_;
    ::google::protobuf::internal::ArenaStringPtr shipping_tracking_id_;
    ::oteldemo::Money* shipping_cost_;
    ::oteldemo::Address* shipping_address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class SendOrderConfirmationRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.SendOrderConfirmationRequest) */ {
 public:
  inline SendOrderConfirmationRequest() : SendOrderConfirmationRequest(nullptr) {}
  ~SendOrderConfirmationRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SendOrderConfirmationRequest(::google::protobuf::internal::ConstantInitialized);

  SendOrderConfirmationRequest(const SendOrderConfirmationRequest& from);
  SendOrderConfirmationRequest(SendOrderConfirmationRequest&& from) noexcept
    : SendOrderConfirmationRequest() {
    *this = ::std::move(from);
  }

  inline SendOrderConfirmationRequest& operator=(const SendOrderConfirmationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendOrderConfirmationRequest& operator=(SendOrderConfirmationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendOrderConfirmationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendOrderConfirmationRequest* internal_default_instance() {
    return reinterpret_cast<const SendOrderConfirmationRequest*>(
               &_SendOrderConfirmationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SendOrderConfirmationRequest& a, SendOrderConfirmationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendOrderConfirmationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendOrderConfirmationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendOrderConfirmationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendOrderConfirmationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SendOrderConfirmationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SendOrderConfirmationRequest& from) {
    SendOrderConfirmationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendOrderConfirmationRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.SendOrderConfirmationRequest";
  }
  protected:
  explicit SendOrderConfirmationRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string email = 1;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // .oteldemo.OrderResult order = 2;
  bool has_order() const;
  void clear_order() ;
  const ::oteldemo::OrderResult& order() const;
  PROTOBUF_NODISCARD ::oteldemo::OrderResult* release_order();
  ::oteldemo::OrderResult* mutable_order();
  void set_allocated_order(::oteldemo::OrderResult* value);
  void unsafe_arena_set_allocated_order(::oteldemo::OrderResult* value);
  ::oteldemo::OrderResult* unsafe_arena_release_order();

  private:
  const ::oteldemo::OrderResult& _internal_order() const;
  ::oteldemo::OrderResult* _internal_mutable_order();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.SendOrderConfirmationRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::oteldemo::OrderResult* order_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class PlaceOrderRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.PlaceOrderRequest) */ {
 public:
  inline PlaceOrderRequest() : PlaceOrderRequest(nullptr) {}
  ~PlaceOrderRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlaceOrderRequest(::google::protobuf::internal::ConstantInitialized);

  PlaceOrderRequest(const PlaceOrderRequest& from);
  PlaceOrderRequest(PlaceOrderRequest&& from) noexcept
    : PlaceOrderRequest() {
    *this = ::std::move(from);
  }

  inline PlaceOrderRequest& operator=(const PlaceOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaceOrderRequest& operator=(PlaceOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaceOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaceOrderRequest* internal_default_instance() {
    return reinterpret_cast<const PlaceOrderRequest*>(
               &_PlaceOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(PlaceOrderRequest& a, PlaceOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaceOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaceOrderRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaceOrderRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaceOrderRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlaceOrderRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlaceOrderRequest& from) {
    PlaceOrderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaceOrderRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.PlaceOrderRequest";
  }
  protected:
  explicit PlaceOrderRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kUserCurrencyFieldNumber = 2,
    kEmailFieldNumber = 5,
    kAddressFieldNumber = 3,
    kCreditCardFieldNumber = 6,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* ptr);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string user_currency = 2;
  void clear_user_currency() ;
  const std::string& user_currency() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_currency(Arg_&& arg, Args_... args);
  std::string* mutable_user_currency();
  PROTOBUF_NODISCARD std::string* release_user_currency();
  void set_allocated_user_currency(std::string* ptr);

  private:
  const std::string& _internal_user_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_currency(
      const std::string& value);
  std::string* _internal_mutable_user_currency();

  public:
  // string email = 5;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // .oteldemo.Address address = 3;
  bool has_address() const;
  void clear_address() ;
  const ::oteldemo::Address& address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_address();
  ::oteldemo::Address* mutable_address();
  void set_allocated_address(::oteldemo::Address* value);
  void unsafe_arena_set_allocated_address(::oteldemo::Address* value);
  ::oteldemo::Address* unsafe_arena_release_address();

  private:
  const ::oteldemo::Address& _internal_address() const;
  ::oteldemo::Address* _internal_mutable_address();

  public:
  // .oteldemo.CreditCardInfo credit_card = 6;
  bool has_credit_card() const;
  void clear_credit_card() ;
  const ::oteldemo::CreditCardInfo& credit_card() const;
  PROTOBUF_NODISCARD ::oteldemo::CreditCardInfo* release_credit_card();
  ::oteldemo::CreditCardInfo* mutable_credit_card();
  void set_allocated_credit_card(::oteldemo::CreditCardInfo* value);
  void unsafe_arena_set_allocated_credit_card(::oteldemo::CreditCardInfo* value);
  ::oteldemo::CreditCardInfo* unsafe_arena_release_credit_card();

  private:
  const ::oteldemo::CreditCardInfo& _internal_credit_card() const;
  ::oteldemo::CreditCardInfo* _internal_mutable_credit_card();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.PlaceOrderRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 2, 60, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr user_currency_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::oteldemo::Address* address_;
    ::oteldemo::CreditCardInfo* credit_card_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class PlaceOrderResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.PlaceOrderResponse) */ {
 public:
  inline PlaceOrderResponse() : PlaceOrderResponse(nullptr) {}
  ~PlaceOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlaceOrderResponse(::google::protobuf::internal::ConstantInitialized);

  PlaceOrderResponse(const PlaceOrderResponse& from);
  PlaceOrderResponse(PlaceOrderResponse&& from) noexcept
    : PlaceOrderResponse() {
    *this = ::std::move(from);
  }

  inline PlaceOrderResponse& operator=(const PlaceOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaceOrderResponse& operator=(PlaceOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaceOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaceOrderResponse* internal_default_instance() {
    return reinterpret_cast<const PlaceOrderResponse*>(
               &_PlaceOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PlaceOrderResponse& a, PlaceOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaceOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaceOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaceOrderResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaceOrderResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlaceOrderResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlaceOrderResponse& from) {
    PlaceOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaceOrderResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.PlaceOrderResponse";
  }
  protected:
  explicit PlaceOrderResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderFieldNumber = 1,
  };
  // .oteldemo.OrderResult order = 1;
  bool has_order() const;
  void clear_order() ;
  const ::oteldemo::OrderResult& order() const;
  PROTOBUF_NODISCARD ::oteldemo::OrderResult* release_order();
  ::oteldemo::OrderResult* mutable_order();
  void set_allocated_order(::oteldemo::OrderResult* value);
  void unsafe_arena_set_allocated_order(::oteldemo::OrderResult* value);
  ::oteldemo::OrderResult* unsafe_arena_release_order();

  private:
  const ::oteldemo::OrderResult& _internal_order() const;
  ::oteldemo::OrderResult* _internal_mutable_order();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.PlaceOrderResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::oteldemo::OrderResult* order_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class AdRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.AdRequest) */ {
 public:
  inline AdRequest() : AdRequest(nullptr) {}
  ~AdRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AdRequest(::google::protobuf::internal::ConstantInitialized);

  AdRequest(const AdRequest& from);
  AdRequest(AdRequest&& from) noexcept
    : AdRequest() {
    *this = ::std::move(from);
  }

  inline AdRequest& operator=(const AdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdRequest& operator=(AdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdRequest* internal_default_instance() {
    return reinterpret_cast<const AdRequest*>(
               &_AdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(AdRequest& a, AdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AdRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AdRequest& from) {
    AdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.AdRequest";
  }
  protected:
  explicit AdRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextKeysFieldNumber = 1,
  };
  // repeated string context_keys = 1;
  int context_keys_size() const;
  private:
  int _internal_context_keys_size() const;

  public:
  void clear_context_keys() ;
  const std::string& context_keys(int index) const;
  std::string* mutable_context_keys(int index);
  void set_context_keys(int index, const std::string& value);
  void set_context_keys(int index, std::string&& value);
  void set_context_keys(int index, const char* value);
  void set_context_keys(int index, const char* value, std::size_t size);
  void set_context_keys(int index, absl::string_view value);
  std::string* add_context_keys();
  void add_context_keys(const std::string& value);
  void add_context_keys(std::string&& value);
  void add_context_keys(const char* value);
  void add_context_keys(const char* value, std::size_t size);
  void add_context_keys(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& context_keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_context_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_context_keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_context_keys();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.AdRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> context_keys_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class AdResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.AdResponse) */ {
 public:
  inline AdResponse() : AdResponse(nullptr) {}
  ~AdResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AdResponse(::google::protobuf::internal::ConstantInitialized);

  AdResponse(const AdResponse& from);
  AdResponse(AdResponse&& from) noexcept
    : AdResponse() {
    *this = ::std::move(from);
  }

  inline AdResponse& operator=(const AdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdResponse& operator=(AdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdResponse* internal_default_instance() {
    return reinterpret_cast<const AdResponse*>(
               &_AdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AdResponse& a, AdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AdResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AdResponse& from) {
    AdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.AdResponse";
  }
  protected:
  explicit AdResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdsFieldNumber = 1,
  };
  // repeated .oteldemo.Ad ads = 1;
  int ads_size() const;
  private:
  int _internal_ads_size() const;

  public:
  void clear_ads() ;
  ::oteldemo::Ad* mutable_ads(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::Ad >*
      mutable_ads();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::Ad>& _internal_ads() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::Ad>* _internal_mutable_ads();
  public:
  const ::oteldemo::Ad& ads(int index) const;
  ::oteldemo::Ad* add_ads();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::Ad >&
      ads() const;
  // @@protoc_insertion_point(class_scope:oteldemo.AdResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::oteldemo::Ad > ads_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Ad final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.Ad) */ {
 public:
  inline Ad() : Ad(nullptr) {}
  ~Ad() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ad(::google::protobuf::internal::ConstantInitialized);

  Ad(const Ad& from);
  Ad(Ad&& from) noexcept
    : Ad() {
    *this = ::std::move(from);
  }

  inline Ad& operator=(const Ad& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ad& operator=(Ad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ad& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ad* internal_default_instance() {
    return reinterpret_cast<const Ad*>(
               &_Ad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Ad& a, Ad& b) {
    a.Swap(&b);
  }
  inline void Swap(Ad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ad* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ad* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ad>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ad& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Ad& from) {
    Ad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ad* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Ad";
  }
  protected:
  explicit Ad(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedirectUrlFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // string redirect_url = 1;
  void clear_redirect_url() ;
  const std::string& redirect_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redirect_url(Arg_&& arg, Args_... args);
  std::string* mutable_redirect_url();
  PROTOBUF_NODISCARD std::string* release_redirect_url();
  void set_allocated_redirect_url(std::string* ptr);

  private:
  const std::string& _internal_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redirect_url(
      const std::string& value);
  std::string* _internal_mutable_redirect_url();

  public:
  // string text = 2;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.Ad)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr redirect_url_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class Flag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.Flag) */ {
 public:
  inline Flag() : Flag(nullptr) {}
  ~Flag() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Flag(::google::protobuf::internal::ConstantInitialized);

  Flag(const Flag& from);
  Flag(Flag&& from) noexcept
    : Flag() {
    *this = ::std::move(from);
  }

  inline Flag& operator=(const Flag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flag& operator=(Flag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Flag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Flag* internal_default_instance() {
    return reinterpret_cast<const Flag*>(
               &_Flag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Flag& a, Flag& b) {
    a.Swap(&b);
  }
  inline void Swap(Flag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Flag* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Flag* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Flag>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Flag& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Flag& from) {
    Flag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flag* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.Flag";
  }
  protected:
  explicit Flag(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kEnabledFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // bool enabled = 3;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.Flag)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 37, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    bool enabled_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetFlagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetFlagRequest) */ {
 public:
  inline GetFlagRequest() : GetFlagRequest(nullptr) {}
  ~GetFlagRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlagRequest(::google::protobuf::internal::ConstantInitialized);

  GetFlagRequest(const GetFlagRequest& from);
  GetFlagRequest(GetFlagRequest&& from) noexcept
    : GetFlagRequest() {
    *this = ::std::move(from);
  }

  inline GetFlagRequest& operator=(const GetFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlagRequest& operator=(GetFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlagRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlagRequest*>(
               &_GetFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetFlagRequest& a, GetFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlagRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlagRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlagRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetFlagRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetFlagRequest& from) {
    GetFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlagRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetFlagRequest";
  }
  protected:
  explicit GetFlagRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetFlagRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class GetFlagResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetFlagResponse) */ {
 public:
  inline GetFlagResponse() : GetFlagResponse(nullptr) {}
  ~GetFlagResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlagResponse(::google::protobuf::internal::ConstantInitialized);

  GetFlagResponse(const GetFlagResponse& from);
  GetFlagResponse(GetFlagResponse&& from) noexcept
    : GetFlagResponse() {
    *this = ::std::move(from);
  }

  inline GetFlagResponse& operator=(const GetFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlagResponse& operator=(GetFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlagResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlagResponse*>(
               &_GetFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetFlagResponse& a, GetFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlagResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlagResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlagResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetFlagResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetFlagResponse& from) {
    GetFlagResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlagResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.GetFlagResponse";
  }
  protected:
  explicit GetFlagResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // .oteldemo.Flag flag = 1;
  bool has_flag() const;
  void clear_flag() ;
  const ::oteldemo::Flag& flag() const;
  PROTOBUF_NODISCARD ::oteldemo::Flag* release_flag();
  ::oteldemo::Flag* mutable_flag();
  void set_allocated_flag(::oteldemo::Flag* value);
  void unsafe_arena_set_allocated_flag(::oteldemo::Flag* value);
  ::oteldemo::Flag* unsafe_arena_release_flag();

  private:
  const ::oteldemo::Flag& _internal_flag() const;
  ::oteldemo::Flag* _internal_mutable_flag();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.GetFlagResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::oteldemo::Flag* flag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class CreateFlagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.CreateFlagRequest) */ {
 public:
  inline CreateFlagRequest() : CreateFlagRequest(nullptr) {}
  ~CreateFlagRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateFlagRequest(::google::protobuf::internal::ConstantInitialized);

  CreateFlagRequest(const CreateFlagRequest& from);
  CreateFlagRequest(CreateFlagRequest&& from) noexcept
    : CreateFlagRequest() {
    *this = ::std::move(from);
  }

  inline CreateFlagRequest& operator=(const CreateFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlagRequest& operator=(CreateFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFlagRequest* internal_default_instance() {
    return reinterpret_cast<const CreateFlagRequest*>(
               &_CreateFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CreateFlagRequest& a, CreateFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlagRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFlagRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFlagRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateFlagRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateFlagRequest& from) {
    CreateFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlagRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.CreateFlagRequest";
  }
  protected:
  explicit CreateFlagRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kEnabledFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // bool enabled = 3;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.CreateFlagRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    bool enabled_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class CreateFlagResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.CreateFlagResponse) */ {
 public:
  inline CreateFlagResponse() : CreateFlagResponse(nullptr) {}
  ~CreateFlagResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateFlagResponse(::google::protobuf::internal::ConstantInitialized);

  CreateFlagResponse(const CreateFlagResponse& from);
  CreateFlagResponse(CreateFlagResponse&& from) noexcept
    : CreateFlagResponse() {
    *this = ::std::move(from);
  }

  inline CreateFlagResponse& operator=(const CreateFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlagResponse& operator=(CreateFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFlagResponse* internal_default_instance() {
    return reinterpret_cast<const CreateFlagResponse*>(
               &_CreateFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CreateFlagResponse& a, CreateFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlagResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFlagResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFlagResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateFlagResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateFlagResponse& from) {
    CreateFlagResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlagResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.CreateFlagResponse";
  }
  protected:
  explicit CreateFlagResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // .oteldemo.Flag flag = 1;
  bool has_flag() const;
  void clear_flag() ;
  const ::oteldemo::Flag& flag() const;
  PROTOBUF_NODISCARD ::oteldemo::Flag* release_flag();
  ::oteldemo::Flag* mutable_flag();
  void set_allocated_flag(::oteldemo::Flag* value);
  void unsafe_arena_set_allocated_flag(::oteldemo::Flag* value);
  ::oteldemo::Flag* unsafe_arena_release_flag();

  private:
  const ::oteldemo::Flag& _internal_flag() const;
  ::oteldemo::Flag* _internal_mutable_flag();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.CreateFlagResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::oteldemo::Flag* flag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class UpdateFlagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.UpdateFlagRequest) */ {
 public:
  inline UpdateFlagRequest() : UpdateFlagRequest(nullptr) {}
  ~UpdateFlagRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateFlagRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateFlagRequest(const UpdateFlagRequest& from);
  UpdateFlagRequest(UpdateFlagRequest&& from) noexcept
    : UpdateFlagRequest() {
    *this = ::std::move(from);
  }

  inline UpdateFlagRequest& operator=(const UpdateFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFlagRequest& operator=(UpdateFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFlagRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateFlagRequest*>(
               &_UpdateFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(UpdateFlagRequest& a, UpdateFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFlagRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFlagRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFlagRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateFlagRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateFlagRequest& from) {
    UpdateFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFlagRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.UpdateFlagRequest";
  }
  protected:
  explicit UpdateFlagRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // bool enabled = 2;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.UpdateFlagRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool enabled_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class UpdateFlagResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.UpdateFlagResponse) */ {
 public:
  inline UpdateFlagResponse() : UpdateFlagResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateFlagResponse(::google::protobuf::internal::ConstantInitialized);

  UpdateFlagResponse(const UpdateFlagResponse& from);
  UpdateFlagResponse(UpdateFlagResponse&& from) noexcept
    : UpdateFlagResponse() {
    *this = ::std::move(from);
  }

  inline UpdateFlagResponse& operator=(const UpdateFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFlagResponse& operator=(UpdateFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFlagResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateFlagResponse*>(
               &_UpdateFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(UpdateFlagResponse& a, UpdateFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFlagResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFlagResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFlagResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateFlagResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateFlagResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.UpdateFlagResponse";
  }
  protected:
  explicit UpdateFlagResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.UpdateFlagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ListFlagsRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.ListFlagsRequest) */ {
 public:
  inline ListFlagsRequest() : ListFlagsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListFlagsRequest(::google::protobuf::internal::ConstantInitialized);

  ListFlagsRequest(const ListFlagsRequest& from);
  ListFlagsRequest(ListFlagsRequest&& from) noexcept
    : ListFlagsRequest() {
    *this = ::std::move(from);
  }

  inline ListFlagsRequest& operator=(const ListFlagsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFlagsRequest& operator=(ListFlagsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFlagsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFlagsRequest* internal_default_instance() {
    return reinterpret_cast<const ListFlagsRequest*>(
               &_ListFlagsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ListFlagsRequest& a, ListFlagsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFlagsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFlagsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFlagsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFlagsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListFlagsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListFlagsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ListFlagsRequest";
  }
  protected:
  explicit ListFlagsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.ListFlagsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class ListFlagsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListFlagsResponse) */ {
 public:
  inline ListFlagsResponse() : ListFlagsResponse(nullptr) {}
  ~ListFlagsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListFlagsResponse(::google::protobuf::internal::ConstantInitialized);

  ListFlagsResponse(const ListFlagsResponse& from);
  ListFlagsResponse(ListFlagsResponse&& from) noexcept
    : ListFlagsResponse() {
    *this = ::std::move(from);
  }

  inline ListFlagsResponse& operator=(const ListFlagsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFlagsResponse& operator=(ListFlagsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFlagsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFlagsResponse* internal_default_instance() {
    return reinterpret_cast<const ListFlagsResponse*>(
               &_ListFlagsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ListFlagsResponse& a, ListFlagsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFlagsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFlagsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFlagsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFlagsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListFlagsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListFlagsResponse& from) {
    ListFlagsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFlagsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.ListFlagsResponse";
  }
  protected:
  explicit ListFlagsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // repeated .oteldemo.Flag flag = 1;
  int flag_size() const;
  private:
  int _internal_flag_size() const;

  public:
  void clear_flag() ;
  ::oteldemo::Flag* mutable_flag(int index);
  ::google::protobuf::RepeatedPtrField< ::oteldemo::Flag >*
      mutable_flag();
  private:
  const ::google::protobuf::RepeatedPtrField<::oteldemo::Flag>& _internal_flag() const;
  ::google::protobuf::RepeatedPtrField<::oteldemo::Flag>* _internal_mutable_flag();
  public:
  const ::oteldemo::Flag& flag(int index) const;
  ::oteldemo::Flag* add_flag();
  const ::google::protobuf::RepeatedPtrField< ::oteldemo::Flag >&
      flag() const;
  // @@protoc_insertion_point(class_scope:oteldemo.ListFlagsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::oteldemo::Flag > flag_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class DeleteFlagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oteldemo.DeleteFlagRequest) */ {
 public:
  inline DeleteFlagRequest() : DeleteFlagRequest(nullptr) {}
  ~DeleteFlagRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteFlagRequest(::google::protobuf::internal::ConstantInitialized);

  DeleteFlagRequest(const DeleteFlagRequest& from);
  DeleteFlagRequest(DeleteFlagRequest&& from) noexcept
    : DeleteFlagRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFlagRequest& operator=(const DeleteFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlagRequest& operator=(DeleteFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFlagRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFlagRequest*>(
               &_DeleteFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(DeleteFlagRequest& a, DeleteFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlagRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFlagRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFlagRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteFlagRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteFlagRequest& from) {
    DeleteFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFlagRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.DeleteFlagRequest";
  }
  protected:
  explicit DeleteFlagRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:oteldemo.DeleteFlagRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};// -------------------------------------------------------------------

class DeleteFlagResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.DeleteFlagResponse) */ {
 public:
  inline DeleteFlagResponse() : DeleteFlagResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteFlagResponse(::google::protobuf::internal::ConstantInitialized);

  DeleteFlagResponse(const DeleteFlagResponse& from);
  DeleteFlagResponse(DeleteFlagResponse&& from) noexcept
    : DeleteFlagResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFlagResponse& operator=(const DeleteFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlagResponse& operator=(DeleteFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFlagResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFlagResponse*>(
               &_DeleteFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(DeleteFlagResponse& a, DeleteFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlagResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFlagResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFlagResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteFlagResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteFlagResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "oteldemo.DeleteFlagResponse";
  }
  protected:
  explicit DeleteFlagResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.DeleteFlagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_demo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CartItem

// string product_id = 1;
inline void CartItem::clear_product_id() {
  _impl_.product_id_.ClearToEmpty();
}
inline const std::string& CartItem::product_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.CartItem.product_id)
  return _internal_product_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CartItem::set_product_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CartItem.product_id)
}
inline std::string* CartItem::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.CartItem.product_id)
  return _s;
}
inline const std::string& CartItem::_internal_product_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_id_.Get();
}
inline void CartItem::_internal_set_product_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CartItem::_internal_mutable_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.product_id_.Mutable( GetArenaForAllocation());
}
inline std::string* CartItem::release_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CartItem.product_id)
  return _impl_.product_id_.Release();
}
inline void CartItem::set_allocated_product_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.product_id_.IsDefault()) {
          _impl_.product_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CartItem.product_id)
}

// int32 quantity = 2;
inline void CartItem::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline ::int32_t CartItem::quantity() const {
  // @@protoc_insertion_point(field_get:oteldemo.CartItem.quantity)
  return _internal_quantity();
}
inline void CartItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:oteldemo.CartItem.quantity)
}
inline ::int32_t CartItem::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void CartItem::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// AddItemRequest

// string user_id = 1;
inline void AddItemRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AddItemRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.AddItemRequest.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddItemRequest::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.AddItemRequest.user_id)
}
inline std::string* AddItemRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.AddItemRequest.user_id)
  return _s;
}
inline const std::string& AddItemRequest::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void AddItemRequest::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddItemRequest::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AddItemRequest::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.AddItemRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void AddItemRequest::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AddItemRequest.user_id)
}

// .oteldemo.CartItem item = 2;
inline bool AddItemRequest::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline void AddItemRequest::clear_item() {
  if (_impl_.item_ != nullptr) _impl_.item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::CartItem& AddItemRequest::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::CartItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CartItem&>(::oteldemo::_CartItem_default_instance_);
}
inline const ::oteldemo::CartItem& AddItemRequest::item() const {
  // @@protoc_insertion_point(field_get:oteldemo.AddItemRequest.item)
  return _internal_item();
}
inline void AddItemRequest::unsafe_arena_set_allocated_item(::oteldemo::CartItem* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = reinterpret_cast<::oteldemo::CartItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.AddItemRequest.item)
}
inline ::oteldemo::CartItem* AddItemRequest::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::CartItem* released = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::CartItem* AddItemRequest::unsafe_arena_release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.AddItemRequest.item)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::CartItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::oteldemo::CartItem* AddItemRequest::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CartItem>(GetArenaForAllocation());
    _impl_.item_ = reinterpret_cast<::oteldemo::CartItem*>(p);
  }
  return _impl_.item_;
}
inline ::oteldemo::CartItem* AddItemRequest::mutable_item() {
  ::oteldemo::CartItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:oteldemo.AddItemRequest.item)
  return _msg;
}
inline void AddItemRequest::set_allocated_item(::oteldemo::CartItem* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::CartItem*>(_impl_.item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::CartItem*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.item_ = reinterpret_cast<::oteldemo::CartItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AddItemRequest.item)
}

// -------------------------------------------------------------------

// EmptyCartRequest

// string user_id = 1;
inline void EmptyCartRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& EmptyCartRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.EmptyCartRequest.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmptyCartRequest::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.EmptyCartRequest.user_id)
}
inline std::string* EmptyCartRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.EmptyCartRequest.user_id)
  return _s;
}
inline const std::string& EmptyCartRequest::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void EmptyCartRequest::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EmptyCartRequest::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EmptyCartRequest::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.EmptyCartRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void EmptyCartRequest::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.EmptyCartRequest.user_id)
}

// -------------------------------------------------------------------

// GetCartRequest

// string user_id = 1;
inline void GetCartRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetCartRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetCartRequest.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetCartRequest::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetCartRequest.user_id)
}
inline std::string* GetCartRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetCartRequest.user_id)
  return _s;
}
inline const std::string& GetCartRequest::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void GetCartRequest::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCartRequest::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetCartRequest::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetCartRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetCartRequest::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetCartRequest.user_id)
}

// -------------------------------------------------------------------

// Cart

// string user_id = 1;
inline void Cart::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Cart::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.Cart.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cart::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Cart.user_id)
}
inline std::string* Cart::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.Cart.user_id)
  return _s;
}
inline const std::string& Cart::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void Cart::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Cart::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Cart::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Cart.user_id)
  return _impl_.user_id_.Release();
}
inline void Cart::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Cart.user_id)
}

// repeated .oteldemo.CartItem items = 2;
inline int Cart::_internal_items_size() const {
  return _internal_items().size();
}
inline int Cart::items_size() const {
  return _internal_items_size();
}
inline void Cart::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::oteldemo::CartItem* Cart::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.Cart.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >*
Cart::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.Cart.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::oteldemo::CartItem& Cart::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.Cart.items)
    return _internal_items().Get(index);
}
inline ::oteldemo::CartItem* Cart::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::CartItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.Cart.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >&
Cart::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.Cart.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>&
Cart::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>*
Cart::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ListRecommendationsRequest

// string user_id = 1;
inline void ListRecommendationsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ListRecommendationsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.ListRecommendationsRequest.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListRecommendationsRequest::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsRequest.user_id)
}
inline std::string* ListRecommendationsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.ListRecommendationsRequest.user_id)
  return _s;
}
inline const std::string& ListRecommendationsRequest::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void ListRecommendationsRequest::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRecommendationsRequest::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ListRecommendationsRequest::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ListRecommendationsRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void ListRecommendationsRequest::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ListRecommendationsRequest.user_id)
}

// repeated string product_ids = 2;
inline int ListRecommendationsRequest::_internal_product_ids_size() const {
  return _internal_product_ids().size();
}
inline int ListRecommendationsRequest::product_ids_size() const {
  return _internal_product_ids_size();
}
inline void ListRecommendationsRequest::clear_product_ids() {
  _internal_mutable_product_ids()->Clear();
}
inline std::string* ListRecommendationsRequest::add_product_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_product_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.ListRecommendationsRequest.product_ids)
  return _s;
}
inline const std::string& ListRecommendationsRequest::product_ids(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListRecommendationsRequest.product_ids)
  return _internal_product_ids().Get(index);
}
inline std::string* ListRecommendationsRequest::mutable_product_ids(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListRecommendationsRequest.product_ids)
  return _internal_mutable_product_ids()->Mutable(index);
}
inline void ListRecommendationsRequest::set_product_ids(int index, const std::string& value) {
  _internal_mutable_product_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, std::string&& value) {
  _internal_mutable_product_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_product_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_product_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, absl::string_view value) {
  _internal_mutable_product_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:oteldemo.ListRecommendationsRequest.product_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListRecommendationsRequest::product_ids() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListRecommendationsRequest.product_ids)
  return _internal_product_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* ListRecommendationsRequest::mutable_product_ids() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListRecommendationsRequest.product_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_product_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListRecommendationsRequest::_internal_product_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListRecommendationsRequest::_internal_mutable_product_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.product_ids_;
}

// -------------------------------------------------------------------

// ListRecommendationsResponse

// repeated string product_ids = 1;
inline int ListRecommendationsResponse::_internal_product_ids_size() const {
  return _internal_product_ids().size();
}
inline int ListRecommendationsResponse::product_ids_size() const {
  return _internal_product_ids_size();
}
inline void ListRecommendationsResponse::clear_product_ids() {
  _internal_mutable_product_ids()->Clear();
}
inline std::string* ListRecommendationsResponse::add_product_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_product_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.ListRecommendationsResponse.product_ids)
  return _s;
}
inline const std::string& ListRecommendationsResponse::product_ids(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListRecommendationsResponse.product_ids)
  return _internal_product_ids().Get(index);
}
inline std::string* ListRecommendationsResponse::mutable_product_ids(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListRecommendationsResponse.product_ids)
  return _internal_mutable_product_ids()->Mutable(index);
}
inline void ListRecommendationsResponse::set_product_ids(int index, const std::string& value) {
  _internal_mutable_product_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, std::string&& value) {
  _internal_mutable_product_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_product_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_product_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, absl::string_view value) {
  _internal_mutable_product_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_product_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:oteldemo.ListRecommendationsResponse.product_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListRecommendationsResponse::product_ids() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListRecommendationsResponse.product_ids)
  return _internal_product_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* ListRecommendationsResponse::mutable_product_ids() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListRecommendationsResponse.product_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_product_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListRecommendationsResponse::_internal_product_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListRecommendationsResponse::_internal_mutable_product_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.product_ids_;
}

// -------------------------------------------------------------------

// Product

// string id = 1;
inline void Product::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Product::id() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Product::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.id)
}
inline std::string* Product::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.id)
  return _s;
}
inline const std::string& Product::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Product::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Product::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Product.id)
  return _impl_.id_.Release();
}
inline void Product::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.id)
}

// string name = 2;
inline void Product::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Product::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Product::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.name)
}
inline std::string* Product::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.name)
  return _s;
}
inline const std::string& Product::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Product::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Product::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Product.name)
  return _impl_.name_.Release();
}
inline void Product::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.name)
}

// string description = 3;
inline void Product::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Product::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Product::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.description)
}
inline std::string* Product::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.description)
  return _s;
}
inline const std::string& Product::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void Product::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Product::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Product.description)
  return _impl_.description_.Release();
}
inline void Product::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.description)
}

// string picture = 4;
inline void Product::clear_picture() {
  _impl_.picture_.ClearToEmpty();
}
inline const std::string& Product::picture() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.picture)
  return _internal_picture();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Product::set_picture(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.picture_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.picture)
}
inline std::string* Product::mutable_picture() {
  std::string* _s = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.picture)
  return _s;
}
inline const std::string& Product::_internal_picture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.picture_.Get();
}
inline void Product::_internal_set_picture(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.picture_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.picture_.Mutable( GetArenaForAllocation());
}
inline std::string* Product::release_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Product.picture)
  return _impl_.picture_.Release();
}
inline void Product::set_allocated_picture(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.picture_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.picture_.IsDefault()) {
          _impl_.picture_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.picture)
}

// .oteldemo.Money price_usd = 5;
inline bool Product::has_price_usd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_usd_ != nullptr);
  return value;
}
inline void Product::clear_price_usd() {
  if (_impl_.price_usd_ != nullptr) _impl_.price_usd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Money& Product::_internal_price_usd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Money* p = _impl_.price_usd_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& Product::price_usd() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.price_usd)
  return _internal_price_usd();
}
inline void Product::unsafe_arena_set_allocated_price_usd(::oteldemo::Money* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.price_usd_);
  }
  _impl_.price_usd_ = reinterpret_cast<::oteldemo::Money*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.Product.price_usd)
}
inline ::oteldemo::Money* Product::release_price_usd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* released = _impl_.price_usd_;
  _impl_.price_usd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Money* Product::unsafe_arena_release_price_usd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Product.price_usd)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* temp = _impl_.price_usd_;
  _impl_.price_usd_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* Product::_internal_mutable_price_usd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_usd_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.price_usd_ = reinterpret_cast<::oteldemo::Money*>(p);
  }
  return _impl_.price_usd_;
}
inline ::oteldemo::Money* Product::mutable_price_usd() {
  ::oteldemo::Money* _msg = _internal_mutable_price_usd();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.price_usd)
  return _msg;
}
inline void Product::set_allocated_price_usd(::oteldemo::Money* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Money*>(_impl_.price_usd_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Money*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.price_usd_ = reinterpret_cast<::oteldemo::Money*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.price_usd)
}

// repeated string categories = 6;
inline int Product::_internal_categories_size() const {
  return _internal_categories().size();
}
inline int Product::categories_size() const {
  return _internal_categories_size();
}
inline void Product::clear_categories() {
  _internal_mutable_categories()->Clear();
}
inline std::string* Product::add_categories() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_categories()->Add();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.Product.categories)
  return _s;
}
inline const std::string& Product::categories(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.categories)
  return _internal_categories().Get(index);
}
inline std::string* Product::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.categories)
  return _internal_mutable_categories()->Mutable(index);
}
inline void Product::set_categories(int index, const std::string& value) {
  _internal_mutable_categories()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, std::string&& value) {
  _internal_mutable_categories()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_categories()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_categories()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, absl::string_view value) {
  _internal_mutable_categories()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:oteldemo.Product.categories)
}
inline void Product::add_categories(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_categories()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.Product.categories)
}
inline void Product::add_categories(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_categories()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.Product.categories)
}
inline void Product::add_categories(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_categories()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.Product.categories)
}
inline void Product::add_categories(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_categories()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.Product.categories)
}
inline void Product::add_categories(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_categories()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:oteldemo.Product.categories)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Product::categories() const {
  // @@protoc_insertion_point(field_list:oteldemo.Product.categories)
  return _internal_categories();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Product::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.Product.categories)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_categories();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Product::_internal_categories() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.categories_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Product::_internal_mutable_categories() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.categories_;
}

// -------------------------------------------------------------------

// ListProductsResponse

// repeated .oteldemo.Product products = 1;
inline int ListProductsResponse::_internal_products_size() const {
  return _internal_products().size();
}
inline int ListProductsResponse::products_size() const {
  return _internal_products_size();
}
inline void ListProductsResponse::clear_products() {
  _internal_mutable_products()->Clear();
}
inline ::oteldemo::Product* ListProductsResponse::mutable_products(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListProductsResponse.products)
  return _internal_mutable_products()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >*
ListProductsResponse::mutable_products() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListProductsResponse.products)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_products();
}
inline const ::oteldemo::Product& ListProductsResponse::products(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListProductsResponse.products)
    return _internal_products().Get(index);
}
inline ::oteldemo::Product* ListProductsResponse::add_products() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::Product* _add = _internal_mutable_products()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.ListProductsResponse.products)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >&
ListProductsResponse::products() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListProductsResponse.products)
  return _internal_products();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::Product>&
ListProductsResponse::_internal_products() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.products_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::Product>*
ListProductsResponse::_internal_mutable_products() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.products_;
}

// -------------------------------------------------------------------

// GetProductRequest

// string id = 1;
inline void GetProductRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProductRequest::id() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetProductRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProductRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetProductRequest.id)
}
inline std::string* GetProductRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetProductRequest.id)
  return _s;
}
inline const std::string& GetProductRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetProductRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProductRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProductRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetProductRequest.id)
  return _impl_.id_.Release();
}
inline void GetProductRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetProductRequest.id)
}

// -------------------------------------------------------------------

// SearchProductsRequest

// string query = 1;
inline void SearchProductsRequest::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& SearchProductsRequest::query() const {
  // @@protoc_insertion_point(field_get:oteldemo.SearchProductsRequest.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchProductsRequest::set_query(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.SearchProductsRequest.query)
}
inline std::string* SearchProductsRequest::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:oteldemo.SearchProductsRequest.query)
  return _s;
}
inline const std::string& SearchProductsRequest::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.query_.Get();
}
inline void SearchProductsRequest::_internal_set_query(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchProductsRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.query_.Mutable( GetArenaForAllocation());
}
inline std::string* SearchProductsRequest::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.SearchProductsRequest.query)
  return _impl_.query_.Release();
}
inline void SearchProductsRequest::set_allocated_query(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.SearchProductsRequest.query)
}

// -------------------------------------------------------------------

// SearchProductsResponse

// repeated .oteldemo.Product results = 1;
inline int SearchProductsResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int SearchProductsResponse::results_size() const {
  return _internal_results_size();
}
inline void SearchProductsResponse::clear_results() {
  _internal_mutable_results()->Clear();
}
inline ::oteldemo::Product* SearchProductsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.SearchProductsResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >*
SearchProductsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.SearchProductsResponse.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::oteldemo::Product& SearchProductsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.SearchProductsResponse.results)
    return _internal_results().Get(index);
}
inline ::oteldemo::Product* SearchProductsResponse::add_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::Product* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.SearchProductsResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::Product >&
SearchProductsResponse::results() const {
  // @@protoc_insertion_point(field_list:oteldemo.SearchProductsResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::Product>&
SearchProductsResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::Product>*
SearchProductsResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// -------------------------------------------------------------------

// ProductReview

// string username = 1;
inline void ProductReview::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ProductReview::username() const {
  // @@protoc_insertion_point(field_get:oteldemo.ProductReview.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProductReview::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ProductReview.username)
}
inline std::string* ProductReview::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:oteldemo.ProductReview.username)
  return _s;
}
inline const std::string& ProductReview::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void ProductReview::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductReview::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.username_.Mutable( GetArenaForAllocation());
}
inline std::string* ProductReview::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ProductReview.username)
  return _impl_.username_.Release();
}
inline void ProductReview::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ProductReview.username)
}

// string description = 2;
inline void ProductReview::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ProductReview::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.ProductReview.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProductReview::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ProductReview.description)
}
inline std::string* ProductReview::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.ProductReview.description)
  return _s;
}
inline const std::string& ProductReview::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void ProductReview::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductReview::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ProductReview::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ProductReview.description)
  return _impl_.description_.Release();
}
inline void ProductReview::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ProductReview.description)
}

// string score = 3;
inline void ProductReview::clear_score() {
  _impl_.score_.ClearToEmpty();
}
inline const std::string& ProductReview::score() const {
  // @@protoc_insertion_point(field_get:oteldemo.ProductReview.score)
  return _internal_score();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProductReview::set_score(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.score_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ProductReview.score)
}
inline std::string* ProductReview::mutable_score() {
  std::string* _s = _internal_mutable_score();
  // @@protoc_insertion_point(field_mutable:oteldemo.ProductReview.score)
  return _s;
}
inline const std::string& ProductReview::_internal_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_.Get();
}
inline void ProductReview::_internal_set_score(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.score_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductReview::_internal_mutable_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.score_.Mutable( GetArenaForAllocation());
}
inline std::string* ProductReview::release_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ProductReview.score)
  return _impl_.score_.Release();
}
inline void ProductReview::set_allocated_score(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.score_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.score_.IsDefault()) {
          _impl_.score_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ProductReview.score)
}

// -------------------------------------------------------------------

// GetProductReviewsRequest

// string product_id = 1;
inline void GetProductReviewsRequest::clear_product_id() {
  _impl_.product_id_.ClearToEmpty();
}
inline const std::string& GetProductReviewsRequest::product_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetProductReviewsRequest.product_id)
  return _internal_product_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProductReviewsRequest::set_product_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetProductReviewsRequest.product_id)
}
inline std::string* GetProductReviewsRequest::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetProductReviewsRequest.product_id)
  return _s;
}
inline const std::string& GetProductReviewsRequest::_internal_product_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_id_.Get();
}
inline void GetProductReviewsRequest::_internal_set_product_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProductReviewsRequest::_internal_mutable_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.product_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProductReviewsRequest::release_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetProductReviewsRequest.product_id)
  return _impl_.product_id_.Release();
}
inline void GetProductReviewsRequest::set_allocated_product_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.product_id_.IsDefault()) {
          _impl_.product_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetProductReviewsRequest.product_id)
}

// -------------------------------------------------------------------

// GetProductReviewsResponse

// repeated .oteldemo.ProductReview product_reviews = 1;
inline int GetProductReviewsResponse::_internal_product_reviews_size() const {
  return _internal_product_reviews().size();
}
inline int GetProductReviewsResponse::product_reviews_size() const {
  return _internal_product_reviews_size();
}
inline void GetProductReviewsResponse::clear_product_reviews() {
  _internal_mutable_product_reviews()->Clear();
}
inline ::oteldemo::ProductReview* GetProductReviewsResponse::mutable_product_reviews(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.GetProductReviewsResponse.product_reviews)
  return _internal_mutable_product_reviews()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::ProductReview >*
GetProductReviewsResponse::mutable_product_reviews() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.GetProductReviewsResponse.product_reviews)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_product_reviews();
}
inline const ::oteldemo::ProductReview& GetProductReviewsResponse::product_reviews(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.GetProductReviewsResponse.product_reviews)
    return _internal_product_reviews().Get(index);
}
inline ::oteldemo::ProductReview* GetProductReviewsResponse::add_product_reviews() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::ProductReview* _add = _internal_mutable_product_reviews()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.GetProductReviewsResponse.product_reviews)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::ProductReview >&
GetProductReviewsResponse::product_reviews() const {
  // @@protoc_insertion_point(field_list:oteldemo.GetProductReviewsResponse.product_reviews)
  return _internal_product_reviews();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::ProductReview>&
GetProductReviewsResponse::_internal_product_reviews() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_reviews_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::ProductReview>*
GetProductReviewsResponse::_internal_mutable_product_reviews() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.product_reviews_;
}

// -------------------------------------------------------------------

// GetAverageProductReviewScoreRequest

// string product_id = 1;
inline void GetAverageProductReviewScoreRequest::clear_product_id() {
  _impl_.product_id_.ClearToEmpty();
}
inline const std::string& GetAverageProductReviewScoreRequest::product_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetAverageProductReviewScoreRequest.product_id)
  return _internal_product_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAverageProductReviewScoreRequest::set_product_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetAverageProductReviewScoreRequest.product_id)
}
inline std::string* GetAverageProductReviewScoreRequest::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetAverageProductReviewScoreRequest.product_id)
  return _s;
}
inline const std::string& GetAverageProductReviewScoreRequest::_internal_product_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_id_.Get();
}
inline void GetAverageProductReviewScoreRequest::_internal_set_product_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAverageProductReviewScoreRequest::_internal_mutable_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.product_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAverageProductReviewScoreRequest::release_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetAverageProductReviewScoreRequest.product_id)
  return _impl_.product_id_.Release();
}
inline void GetAverageProductReviewScoreRequest::set_allocated_product_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.product_id_.IsDefault()) {
          _impl_.product_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetAverageProductReviewScoreRequest.product_id)
}

// -------------------------------------------------------------------

// GetAverageProductReviewScoreResponse

// string average_score = 1;
inline void GetAverageProductReviewScoreResponse::clear_average_score() {
  _impl_.average_score_.ClearToEmpty();
}
inline const std::string& GetAverageProductReviewScoreResponse::average_score() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetAverageProductReviewScoreResponse.average_score)
  return _internal_average_score();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAverageProductReviewScoreResponse::set_average_score(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_score_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetAverageProductReviewScoreResponse.average_score)
}
inline std::string* GetAverageProductReviewScoreResponse::mutable_average_score() {
  std::string* _s = _internal_mutable_average_score();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetAverageProductReviewScoreResponse.average_score)
  return _s;
}
inline const std::string& GetAverageProductReviewScoreResponse::_internal_average_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_score_.Get();
}
inline void GetAverageProductReviewScoreResponse::_internal_set_average_score(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_score_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAverageProductReviewScoreResponse::_internal_mutable_average_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.average_score_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAverageProductReviewScoreResponse::release_average_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetAverageProductReviewScoreResponse.average_score)
  return _impl_.average_score_.Release();
}
inline void GetAverageProductReviewScoreResponse::set_allocated_average_score(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.average_score_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.average_score_.IsDefault()) {
          _impl_.average_score_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetAverageProductReviewScoreResponse.average_score)
}

// -------------------------------------------------------------------

// AskProductAIAssistantRequest

// string product_id = 1;
inline void AskProductAIAssistantRequest::clear_product_id() {
  _impl_.product_id_.ClearToEmpty();
}
inline const std::string& AskProductAIAssistantRequest::product_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.AskProductAIAssistantRequest.product_id)
  return _internal_product_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskProductAIAssistantRequest::set_product_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.AskProductAIAssistantRequest.product_id)
}
inline std::string* AskProductAIAssistantRequest::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.AskProductAIAssistantRequest.product_id)
  return _s;
}
inline const std::string& AskProductAIAssistantRequest::_internal_product_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_id_.Get();
}
inline void AskProductAIAssistantRequest::_internal_set_product_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.product_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AskProductAIAssistantRequest::_internal_mutable_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.product_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AskProductAIAssistantRequest::release_product_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.AskProductAIAssistantRequest.product_id)
  return _impl_.product_id_.Release();
}
inline void AskProductAIAssistantRequest::set_allocated_product_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.product_id_.IsDefault()) {
          _impl_.product_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AskProductAIAssistantRequest.product_id)
}

// string question = 2;
inline void AskProductAIAssistantRequest::clear_question() {
  _impl_.question_.ClearToEmpty();
}
inline const std::string& AskProductAIAssistantRequest::question() const {
  // @@protoc_insertion_point(field_get:oteldemo.AskProductAIAssistantRequest.question)
  return _internal_question();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskProductAIAssistantRequest::set_question(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.question_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.AskProductAIAssistantRequest.question)
}
inline std::string* AskProductAIAssistantRequest::mutable_question() {
  std::string* _s = _internal_mutable_question();
  // @@protoc_insertion_point(field_mutable:oteldemo.AskProductAIAssistantRequest.question)
  return _s;
}
inline const std::string& AskProductAIAssistantRequest::_internal_question() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.question_.Get();
}
inline void AskProductAIAssistantRequest::_internal_set_question(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.question_.Set(value, GetArenaForAllocation());
}
inline std::string* AskProductAIAssistantRequest::_internal_mutable_question() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.question_.Mutable( GetArenaForAllocation());
}
inline std::string* AskProductAIAssistantRequest::release_question() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.AskProductAIAssistantRequest.question)
  return _impl_.question_.Release();
}
inline void AskProductAIAssistantRequest::set_allocated_question(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.question_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.question_.IsDefault()) {
          _impl_.question_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AskProductAIAssistantRequest.question)
}

// -------------------------------------------------------------------

// AskProductAIAssistantResponse

// string response = 1;
inline void AskProductAIAssistantResponse::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& AskProductAIAssistantResponse::response() const {
  // @@protoc_insertion_point(field_get:oteldemo.AskProductAIAssistantResponse.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskProductAIAssistantResponse::set_response(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.AskProductAIAssistantResponse.response)
}
inline std::string* AskProductAIAssistantResponse::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:oteldemo.AskProductAIAssistantResponse.response)
  return _s;
}
inline const std::string& AskProductAIAssistantResponse::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.response_.Get();
}
inline void AskProductAIAssistantResponse::_internal_set_response(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* AskProductAIAssistantResponse::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* AskProductAIAssistantResponse::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.AskProductAIAssistantResponse.response)
  return _impl_.response_.Release();
}
inline void AskProductAIAssistantResponse::set_allocated_response(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AskProductAIAssistantResponse.response)
}

// -------------------------------------------------------------------

// GetQuoteRequest

// .oteldemo.Address address = 1;
inline bool GetQuoteRequest::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void GetQuoteRequest::clear_address() {
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Address& GetQuoteRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& GetQuoteRequest::address() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetQuoteRequest.address)
  return _internal_address();
}
inline void GetQuoteRequest::unsafe_arena_set_allocated_address(::oteldemo::Address* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.GetQuoteRequest.address)
}
inline ::oteldemo::Address* GetQuoteRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Address* released = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Address* GetQuoteRequest::unsafe_arena_release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetQuoteRequest.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* GetQuoteRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(p);
  }
  return _impl_.address_;
}
inline ::oteldemo::Address* GetQuoteRequest::mutable_address() {
  ::oteldemo::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetQuoteRequest.address)
  return _msg;
}
inline void GetQuoteRequest::set_allocated_address(::oteldemo::Address* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Address*>(_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Address*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetQuoteRequest.address)
}

// repeated .oteldemo.CartItem items = 2;
inline int GetQuoteRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int GetQuoteRequest::items_size() const {
  return _internal_items_size();
}
inline void GetQuoteRequest::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::oteldemo::CartItem* GetQuoteRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.GetQuoteRequest.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >*
GetQuoteRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.GetQuoteRequest.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::oteldemo::CartItem& GetQuoteRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.GetQuoteRequest.items)
    return _internal_items().Get(index);
}
inline ::oteldemo::CartItem* GetQuoteRequest::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::CartItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.GetQuoteRequest.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >&
GetQuoteRequest::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.GetQuoteRequest.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>&
GetQuoteRequest::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>*
GetQuoteRequest::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// GetQuoteResponse

// .oteldemo.Money cost_usd = 1;
inline bool GetQuoteResponse::has_cost_usd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cost_usd_ != nullptr);
  return value;
}
inline void GetQuoteResponse::clear_cost_usd() {
  if (_impl_.cost_usd_ != nullptr) _impl_.cost_usd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Money& GetQuoteResponse::_internal_cost_usd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Money* p = _impl_.cost_usd_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& GetQuoteResponse::cost_usd() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetQuoteResponse.cost_usd)
  return _internal_cost_usd();
}
inline void GetQuoteResponse::unsafe_arena_set_allocated_cost_usd(::oteldemo::Money* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cost_usd_);
  }
  _impl_.cost_usd_ = reinterpret_cast<::oteldemo::Money*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.GetQuoteResponse.cost_usd)
}
inline ::oteldemo::Money* GetQuoteResponse::release_cost_usd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* released = _impl_.cost_usd_;
  _impl_.cost_usd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Money* GetQuoteResponse::unsafe_arena_release_cost_usd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetQuoteResponse.cost_usd)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* temp = _impl_.cost_usd_;
  _impl_.cost_usd_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* GetQuoteResponse::_internal_mutable_cost_usd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cost_usd_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.cost_usd_ = reinterpret_cast<::oteldemo::Money*>(p);
  }
  return _impl_.cost_usd_;
}
inline ::oteldemo::Money* GetQuoteResponse::mutable_cost_usd() {
  ::oteldemo::Money* _msg = _internal_mutable_cost_usd();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetQuoteResponse.cost_usd)
  return _msg;
}
inline void GetQuoteResponse::set_allocated_cost_usd(::oteldemo::Money* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Money*>(_impl_.cost_usd_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Money*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.cost_usd_ = reinterpret_cast<::oteldemo::Money*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetQuoteResponse.cost_usd)
}

// -------------------------------------------------------------------

// ShipOrderRequest

// .oteldemo.Address address = 1;
inline bool ShipOrderRequest::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void ShipOrderRequest::clear_address() {
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Address& ShipOrderRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& ShipOrderRequest::address() const {
  // @@protoc_insertion_point(field_get:oteldemo.ShipOrderRequest.address)
  return _internal_address();
}
inline void ShipOrderRequest::unsafe_arena_set_allocated_address(::oteldemo::Address* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.ShipOrderRequest.address)
}
inline ::oteldemo::Address* ShipOrderRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Address* released = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Address* ShipOrderRequest::unsafe_arena_release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ShipOrderRequest.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* ShipOrderRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(p);
  }
  return _impl_.address_;
}
inline ::oteldemo::Address* ShipOrderRequest::mutable_address() {
  ::oteldemo::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.ShipOrderRequest.address)
  return _msg;
}
inline void ShipOrderRequest::set_allocated_address(::oteldemo::Address* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Address*>(_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Address*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ShipOrderRequest.address)
}

// repeated .oteldemo.CartItem items = 2;
inline int ShipOrderRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int ShipOrderRequest::items_size() const {
  return _internal_items_size();
}
inline void ShipOrderRequest::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::oteldemo::CartItem* ShipOrderRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ShipOrderRequest.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >*
ShipOrderRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ShipOrderRequest.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::oteldemo::CartItem& ShipOrderRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ShipOrderRequest.items)
    return _internal_items().Get(index);
}
inline ::oteldemo::CartItem* ShipOrderRequest::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::CartItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.ShipOrderRequest.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::CartItem >&
ShipOrderRequest::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.ShipOrderRequest.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>&
ShipOrderRequest::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::CartItem>*
ShipOrderRequest::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// ShipOrderResponse

// string tracking_id = 1;
inline void ShipOrderResponse::clear_tracking_id() {
  _impl_.tracking_id_.ClearToEmpty();
}
inline const std::string& ShipOrderResponse::tracking_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.ShipOrderResponse.tracking_id)
  return _internal_tracking_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShipOrderResponse::set_tracking_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tracking_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ShipOrderResponse.tracking_id)
}
inline std::string* ShipOrderResponse::mutable_tracking_id() {
  std::string* _s = _internal_mutable_tracking_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.ShipOrderResponse.tracking_id)
  return _s;
}
inline const std::string& ShipOrderResponse::_internal_tracking_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tracking_id_.Get();
}
inline void ShipOrderResponse::_internal_set_tracking_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tracking_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ShipOrderResponse::_internal_mutable_tracking_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tracking_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ShipOrderResponse::release_tracking_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ShipOrderResponse.tracking_id)
  return _impl_.tracking_id_.Release();
}
inline void ShipOrderResponse::set_allocated_tracking_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tracking_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tracking_id_.IsDefault()) {
          _impl_.tracking_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ShipOrderResponse.tracking_id)
}

// -------------------------------------------------------------------

// Address

// string street_address = 1;
inline void Address::clear_street_address() {
  _impl_.street_address_.ClearToEmpty();
}
inline const std::string& Address::street_address() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.street_address)
  return _internal_street_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_street_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.street_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.street_address)
}
inline std::string* Address::mutable_street_address() {
  std::string* _s = _internal_mutable_street_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.street_address)
  return _s;
}
inline const std::string& Address::_internal_street_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.street_address_.Get();
}
inline void Address::_internal_set_street_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.street_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_street_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.street_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Address::release_street_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Address.street_address)
  return _impl_.street_address_.Release();
}
inline void Address::set_allocated_street_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.street_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.street_address_.IsDefault()) {
          _impl_.street_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.street_address)
}

// string city = 2;
inline void Address::clear_city() {
  _impl_.city_.ClearToEmpty();
}
inline const std::string& Address::city() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.city)
  return _internal_city();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_city(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.city_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.city)
}
inline std::string* Address::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.city)
  return _s;
}
inline const std::string& Address::_internal_city() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.city_.Get();
}
inline void Address::_internal_set_city(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.city_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_city() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.city_.Mutable( GetArenaForAllocation());
}
inline std::string* Address::release_city() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Address.city)
  return _impl_.city_.Release();
}
inline void Address::set_allocated_city(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.city_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.city_.IsDefault()) {
          _impl_.city_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.city)
}

// string state = 3;
inline void Address::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& Address::state() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.state)
}
inline std::string* Address::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.state)
  return _s;
}
inline const std::string& Address::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_.Get();
}
inline void Address::_internal_set_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* Address::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Address.state)
  return _impl_.state_.Release();
}
inline void Address::set_allocated_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.state)
}

// string country = 4;
inline void Address::clear_country() {
  _impl_.country_.ClearToEmpty();
}
inline const std::string& Address::country() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.country)
  return _internal_country();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_country(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.country)
}
inline std::string* Address::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.country)
  return _s;
}
inline const std::string& Address::_internal_country() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.country_.Get();
}
inline void Address::_internal_set_country(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_country() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.country_.Mutable( GetArenaForAllocation());
}
inline std::string* Address::release_country() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Address.country)
  return _impl_.country_.Release();
}
inline void Address::set_allocated_country(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.country_.IsDefault()) {
          _impl_.country_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.country)
}

// string zip_code = 5;
inline void Address::clear_zip_code() {
  _impl_.zip_code_.ClearToEmpty();
}
inline const std::string& Address::zip_code() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.zip_code)
  return _internal_zip_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_zip_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zip_code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.zip_code)
}
inline std::string* Address::mutable_zip_code() {
  std::string* _s = _internal_mutable_zip_code();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.zip_code)
  return _s;
}
inline const std::string& Address::_internal_zip_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zip_code_.Get();
}
inline void Address::_internal_set_zip_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zip_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_zip_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.zip_code_.Mutable( GetArenaForAllocation());
}
inline std::string* Address::release_zip_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Address.zip_code)
  return _impl_.zip_code_.Release();
}
inline void Address::set_allocated_zip_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zip_code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.zip_code_.IsDefault()) {
          _impl_.zip_code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.zip_code)
}

// -------------------------------------------------------------------

// Money

// string currency_code = 1;
inline void Money::clear_currency_code() {
  _impl_.currency_code_.ClearToEmpty();
}
inline const std::string& Money::currency_code() const {
  // @@protoc_insertion_point(field_get:oteldemo.Money.currency_code)
  return _internal_currency_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Money::set_currency_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.currency_code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Money.currency_code)
}
inline std::string* Money::mutable_currency_code() {
  std::string* _s = _internal_mutable_currency_code();
  // @@protoc_insertion_point(field_mutable:oteldemo.Money.currency_code)
  return _s;
}
inline const std::string& Money::_internal_currency_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currency_code_.Get();
}
inline void Money::_internal_set_currency_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.currency_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Money::_internal_mutable_currency_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.currency_code_.Mutable( GetArenaForAllocation());
}
inline std::string* Money::release_currency_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Money.currency_code)
  return _impl_.currency_code_.Release();
}
inline void Money::set_allocated_currency_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currency_code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.currency_code_.IsDefault()) {
          _impl_.currency_code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Money.currency_code)
}

// int64 units = 2;
inline void Money::clear_units() {
  _impl_.units_ = ::int64_t{0};
}
inline ::int64_t Money::units() const {
  // @@protoc_insertion_point(field_get:oteldemo.Money.units)
  return _internal_units();
}
inline void Money::set_units(::int64_t value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:oteldemo.Money.units)
}
inline ::int64_t Money::_internal_units() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.units_;
}
inline void Money::_internal_set_units(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.units_ = value;
}

// int32 nanos = 3;
inline void Money::clear_nanos() {
  _impl_.nanos_ = 0;
}
inline ::int32_t Money::nanos() const {
  // @@protoc_insertion_point(field_get:oteldemo.Money.nanos)
  return _internal_nanos();
}
inline void Money::set_nanos(::int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:oteldemo.Money.nanos)
}
inline ::int32_t Money::_internal_nanos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nanos_;
}
inline void Money::_internal_set_nanos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nanos_ = value;
}

// -------------------------------------------------------------------

// GetSupportedCurrenciesResponse

// repeated string currency_codes = 1;
inline int GetSupportedCurrenciesResponse::_internal_currency_codes_size() const {
  return _internal_currency_codes().size();
}
inline int GetSupportedCurrenciesResponse::currency_codes_size() const {
  return _internal_currency_codes_size();
}
inline void GetSupportedCurrenciesResponse::clear_currency_codes() {
  _internal_mutable_currency_codes()->Clear();
}
inline std::string* GetSupportedCurrenciesResponse::add_currency_codes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_currency_codes()->Add();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _s;
}
inline const std::string& GetSupportedCurrenciesResponse::currency_codes(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _internal_currency_codes().Get(index);
}
inline std::string* GetSupportedCurrenciesResponse::mutable_currency_codes(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _internal_mutable_currency_codes()->Mutable(index);
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, const std::string& value) {
  _internal_mutable_currency_codes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, std::string&& value) {
  _internal_mutable_currency_codes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_currency_codes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_currency_codes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, absl::string_view value) {
  _internal_mutable_currency_codes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_currency_codes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_currency_codes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_currency_codes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_currency_codes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_currency_codes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetSupportedCurrenciesResponse::currency_codes() const {
  // @@protoc_insertion_point(field_list:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _internal_currency_codes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* GetSupportedCurrenciesResponse::mutable_currency_codes() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_currency_codes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetSupportedCurrenciesResponse::_internal_currency_codes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currency_codes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetSupportedCurrenciesResponse::_internal_mutable_currency_codes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.currency_codes_;
}

// -------------------------------------------------------------------

// CurrencyConversionRequest

// .oteldemo.Money from = 1;
inline bool CurrencyConversionRequest::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_ != nullptr);
  return value;
}
inline void CurrencyConversionRequest::clear_from() {
  if (_impl_.from_ != nullptr) _impl_.from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Money& CurrencyConversionRequest::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Money* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& CurrencyConversionRequest::from() const {
  // @@protoc_insertion_point(field_get:oteldemo.CurrencyConversionRequest.from)
  return _internal_from();
}
inline void CurrencyConversionRequest::unsafe_arena_set_allocated_from(::oteldemo::Money* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = reinterpret_cast<::oteldemo::Money*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.CurrencyConversionRequest.from)
}
inline ::oteldemo::Money* CurrencyConversionRequest::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* released = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Money* CurrencyConversionRequest::unsafe_arena_release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CurrencyConversionRequest.from)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* CurrencyConversionRequest::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.from_ = reinterpret_cast<::oteldemo::Money*>(p);
  }
  return _impl_.from_;
}
inline ::oteldemo::Money* CurrencyConversionRequest::mutable_from() {
  ::oteldemo::Money* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:oteldemo.CurrencyConversionRequest.from)
  return _msg;
}
inline void CurrencyConversionRequest::set_allocated_from(::oteldemo::Money* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Money*>(_impl_.from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Money*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.from_ = reinterpret_cast<::oteldemo::Money*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CurrencyConversionRequest.from)
}

// string to_code = 2;
inline void CurrencyConversionRequest::clear_to_code() {
  _impl_.to_code_.ClearToEmpty();
}
inline const std::string& CurrencyConversionRequest::to_code() const {
  // @@protoc_insertion_point(field_get:oteldemo.CurrencyConversionRequest.to_code)
  return _internal_to_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CurrencyConversionRequest::set_to_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CurrencyConversionRequest.to_code)
}
inline std::string* CurrencyConversionRequest::mutable_to_code() {
  std::string* _s = _internal_mutable_to_code();
  // @@protoc_insertion_point(field_mutable:oteldemo.CurrencyConversionRequest.to_code)
  return _s;
}
inline const std::string& CurrencyConversionRequest::_internal_to_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_code_.Get();
}
inline void CurrencyConversionRequest::_internal_set_to_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CurrencyConversionRequest::_internal_mutable_to_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.to_code_.Mutable( GetArenaForAllocation());
}
inline std::string* CurrencyConversionRequest::release_to_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CurrencyConversionRequest.to_code)
  return _impl_.to_code_.Release();
}
inline void CurrencyConversionRequest::set_allocated_to_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_code_.IsDefault()) {
          _impl_.to_code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CurrencyConversionRequest.to_code)
}

// -------------------------------------------------------------------

// CreditCardInfo

// string credit_card_number = 1;
inline void CreditCardInfo::clear_credit_card_number() {
  _impl_.credit_card_number_.ClearToEmpty();
}
inline const std::string& CreditCardInfo::credit_card_number() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_number)
  return _internal_credit_card_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreditCardInfo::set_credit_card_number(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credit_card_number_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_number)
}
inline std::string* CreditCardInfo::mutable_credit_card_number() {
  std::string* _s = _internal_mutable_credit_card_number();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreditCardInfo.credit_card_number)
  return _s;
}
inline const std::string& CreditCardInfo::_internal_credit_card_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.credit_card_number_.Get();
}
inline void CreditCardInfo::_internal_set_credit_card_number(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credit_card_number_.Set(value, GetArenaForAllocation());
}
inline std::string* CreditCardInfo::_internal_mutable_credit_card_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.credit_card_number_.Mutable( GetArenaForAllocation());
}
inline std::string* CreditCardInfo::release_credit_card_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CreditCardInfo.credit_card_number)
  return _impl_.credit_card_number_.Release();
}
inline void CreditCardInfo::set_allocated_credit_card_number(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.credit_card_number_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.credit_card_number_.IsDefault()) {
          _impl_.credit_card_number_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreditCardInfo.credit_card_number)
}

// int32 credit_card_cvv = 2;
inline void CreditCardInfo::clear_credit_card_cvv() {
  _impl_.credit_card_cvv_ = 0;
}
inline ::int32_t CreditCardInfo::credit_card_cvv() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_cvv)
  return _internal_credit_card_cvv();
}
inline void CreditCardInfo::set_credit_card_cvv(::int32_t value) {
  _internal_set_credit_card_cvv(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_cvv)
}
inline ::int32_t CreditCardInfo::_internal_credit_card_cvv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.credit_card_cvv_;
}
inline void CreditCardInfo::_internal_set_credit_card_cvv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credit_card_cvv_ = value;
}

// int32 credit_card_expiration_year = 3;
inline void CreditCardInfo::clear_credit_card_expiration_year() {
  _impl_.credit_card_expiration_year_ = 0;
}
inline ::int32_t CreditCardInfo::credit_card_expiration_year() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_expiration_year)
  return _internal_credit_card_expiration_year();
}
inline void CreditCardInfo::set_credit_card_expiration_year(::int32_t value) {
  _internal_set_credit_card_expiration_year(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_expiration_year)
}
inline ::int32_t CreditCardInfo::_internal_credit_card_expiration_year() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.credit_card_expiration_year_;
}
inline void CreditCardInfo::_internal_set_credit_card_expiration_year(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credit_card_expiration_year_ = value;
}

// int32 credit_card_expiration_month = 4;
inline void CreditCardInfo::clear_credit_card_expiration_month() {
  _impl_.credit_card_expiration_month_ = 0;
}
inline ::int32_t CreditCardInfo::credit_card_expiration_month() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_expiration_month)
  return _internal_credit_card_expiration_month();
}
inline void CreditCardInfo::set_credit_card_expiration_month(::int32_t value) {
  _internal_set_credit_card_expiration_month(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_expiration_month)
}
inline ::int32_t CreditCardInfo::_internal_credit_card_expiration_month() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.credit_card_expiration_month_;
}
inline void CreditCardInfo::_internal_set_credit_card_expiration_month(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credit_card_expiration_month_ = value;
}

// -------------------------------------------------------------------

// ChargeRequest

// .oteldemo.Money amount = 1;
inline bool ChargeRequest::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline void ChargeRequest::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Money& ChargeRequest::_internal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Money* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& ChargeRequest::amount() const {
  // @@protoc_insertion_point(field_get:oteldemo.ChargeRequest.amount)
  return _internal_amount();
}
inline void ChargeRequest::unsafe_arena_set_allocated_amount(::oteldemo::Money* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = reinterpret_cast<::oteldemo::Money*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.ChargeRequest.amount)
}
inline ::oteldemo::Money* ChargeRequest::release_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* released = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Money* ChargeRequest::unsafe_arena_release_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ChargeRequest.amount)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* ChargeRequest::_internal_mutable_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.amount_ = reinterpret_cast<::oteldemo::Money*>(p);
  }
  return _impl_.amount_;
}
inline ::oteldemo::Money* ChargeRequest::mutable_amount() {
  ::oteldemo::Money* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:oteldemo.ChargeRequest.amount)
  return _msg;
}
inline void ChargeRequest::set_allocated_amount(::oteldemo::Money* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Money*>(_impl_.amount_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Money*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.amount_ = reinterpret_cast<::oteldemo::Money*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ChargeRequest.amount)
}

// .oteldemo.CreditCardInfo credit_card = 2;
inline bool ChargeRequest::has_credit_card() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.credit_card_ != nullptr);
  return value;
}
inline void ChargeRequest::clear_credit_card() {
  if (_impl_.credit_card_ != nullptr) _impl_.credit_card_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::oteldemo::CreditCardInfo& ChargeRequest::_internal_credit_card() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::CreditCardInfo* p = _impl_.credit_card_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CreditCardInfo&>(::oteldemo::_CreditCardInfo_default_instance_);
}
inline const ::oteldemo::CreditCardInfo& ChargeRequest::credit_card() const {
  // @@protoc_insertion_point(field_get:oteldemo.ChargeRequest.credit_card)
  return _internal_credit_card();
}
inline void ChargeRequest::unsafe_arena_set_allocated_credit_card(::oteldemo::CreditCardInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.credit_card_);
  }
  _impl_.credit_card_ = reinterpret_cast<::oteldemo::CreditCardInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.ChargeRequest.credit_card)
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::release_credit_card() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::CreditCardInfo* released = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::unsafe_arena_release_credit_card() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ChargeRequest.credit_card)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::CreditCardInfo* temp = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
  return temp;
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::_internal_mutable_credit_card() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.credit_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CreditCardInfo>(GetArenaForAllocation());
    _impl_.credit_card_ = reinterpret_cast<::oteldemo::CreditCardInfo*>(p);
  }
  return _impl_.credit_card_;
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::mutable_credit_card() {
  ::oteldemo::CreditCardInfo* _msg = _internal_mutable_credit_card();
  // @@protoc_insertion_point(field_mutable:oteldemo.ChargeRequest.credit_card)
  return _msg;
}
inline void ChargeRequest::set_allocated_credit_card(::oteldemo::CreditCardInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::CreditCardInfo*>(_impl_.credit_card_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::CreditCardInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.credit_card_ = reinterpret_cast<::oteldemo::CreditCardInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ChargeRequest.credit_card)
}

// -------------------------------------------------------------------

// ChargeResponse

// string transaction_id = 1;
inline void ChargeResponse::clear_transaction_id() {
  _impl_.transaction_id_.ClearToEmpty();
}
inline const std::string& ChargeResponse::transaction_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.ChargeResponse.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChargeResponse::set_transaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ChargeResponse.transaction_id)
}
inline std::string* ChargeResponse::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.ChargeResponse.transaction_id)
  return _s;
}
inline const std::string& ChargeResponse::_internal_transaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transaction_id_.Get();
}
inline void ChargeResponse::_internal_set_transaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChargeResponse::_internal_mutable_transaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.transaction_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChargeResponse::release_transaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.ChargeResponse.transaction_id)
  return _impl_.transaction_id_.Release();
}
inline void ChargeResponse::set_allocated_transaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transaction_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transaction_id_.IsDefault()) {
          _impl_.transaction_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ChargeResponse.transaction_id)
}

// -------------------------------------------------------------------

// OrderItem

// .oteldemo.CartItem item = 1;
inline bool OrderItem::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline void OrderItem::clear_item() {
  if (_impl_.item_ != nullptr) _impl_.item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::CartItem& OrderItem::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::CartItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CartItem&>(::oteldemo::_CartItem_default_instance_);
}
inline const ::oteldemo::CartItem& OrderItem::item() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderItem.item)
  return _internal_item();
}
inline void OrderItem::unsafe_arena_set_allocated_item(::oteldemo::CartItem* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = reinterpret_cast<::oteldemo::CartItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderItem.item)
}
inline ::oteldemo::CartItem* OrderItem::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::CartItem* released = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::CartItem* OrderItem::unsafe_arena_release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.OrderItem.item)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::CartItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::oteldemo::CartItem* OrderItem::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CartItem>(GetArenaForAllocation());
    _impl_.item_ = reinterpret_cast<::oteldemo::CartItem*>(p);
  }
  return _impl_.item_;
}
inline ::oteldemo::CartItem* OrderItem::mutable_item() {
  ::oteldemo::CartItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderItem.item)
  return _msg;
}
inline void OrderItem::set_allocated_item(::oteldemo::CartItem* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::CartItem*>(_impl_.item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::CartItem*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.item_ = reinterpret_cast<::oteldemo::CartItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderItem.item)
}

// .oteldemo.Money cost = 2;
inline bool OrderItem::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cost_ != nullptr);
  return value;
}
inline void OrderItem::clear_cost() {
  if (_impl_.cost_ != nullptr) _impl_.cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::oteldemo::Money& OrderItem::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Money* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& OrderItem::cost() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderItem.cost)
  return _internal_cost();
}
inline void OrderItem::unsafe_arena_set_allocated_cost(::oteldemo::Money* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = reinterpret_cast<::oteldemo::Money*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderItem.cost)
}
inline ::oteldemo::Money* OrderItem::release_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::Money* released = _impl_.cost_;
  _impl_.cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Money* OrderItem::unsafe_arena_release_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.OrderItem.cost)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::Money* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* OrderItem::_internal_mutable_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.cost_ = reinterpret_cast<::oteldemo::Money*>(p);
  }
  return _impl_.cost_;
}
inline ::oteldemo::Money* OrderItem::mutable_cost() {
  ::oteldemo::Money* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderItem.cost)
  return _msg;
}
inline void OrderItem::set_allocated_cost(::oteldemo::Money* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Money*>(_impl_.cost_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Money*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cost_ = reinterpret_cast<::oteldemo::Money*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderItem.cost)
}

// -------------------------------------------------------------------

// OrderResult

// string order_id = 1;
inline void OrderResult::clear_order_id() {
  _impl_.order_id_.ClearToEmpty();
}
inline const std::string& OrderResult::order_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.order_id)
  return _internal_order_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderResult::set_order_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.order_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.OrderResult.order_id)
}
inline std::string* OrderResult::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.order_id)
  return _s;
}
inline const std::string& OrderResult::_internal_order_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.order_id_.Get();
}
inline void OrderResult::_internal_set_order_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderResult::_internal_mutable_order_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.order_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderResult::release_order_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.order_id)
  return _impl_.order_id_.Release();
}
inline void OrderResult::set_allocated_order_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.order_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_id_.IsDefault()) {
          _impl_.order_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.order_id)
}

// string shipping_tracking_id = 2;
inline void OrderResult::clear_shipping_tracking_id() {
  _impl_.shipping_tracking_id_.ClearToEmpty();
}
inline const std::string& OrderResult::shipping_tracking_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.shipping_tracking_id)
  return _internal_shipping_tracking_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderResult::set_shipping_tracking_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shipping_tracking_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.OrderResult.shipping_tracking_id)
}
inline std::string* OrderResult::mutable_shipping_tracking_id() {
  std::string* _s = _internal_mutable_shipping_tracking_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.shipping_tracking_id)
  return _s;
}
inline const std::string& OrderResult::_internal_shipping_tracking_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shipping_tracking_id_.Get();
}
inline void OrderResult::_internal_set_shipping_tracking_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shipping_tracking_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderResult::_internal_mutable_shipping_tracking_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.shipping_tracking_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderResult::release_shipping_tracking_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.shipping_tracking_id)
  return _impl_.shipping_tracking_id_.Release();
}
inline void OrderResult::set_allocated_shipping_tracking_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shipping_tracking_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shipping_tracking_id_.IsDefault()) {
          _impl_.shipping_tracking_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.shipping_tracking_id)
}

// .oteldemo.Money shipping_cost = 3;
inline bool OrderResult::has_shipping_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shipping_cost_ != nullptr);
  return value;
}
inline void OrderResult::clear_shipping_cost() {
  if (_impl_.shipping_cost_ != nullptr) _impl_.shipping_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Money& OrderResult::_internal_shipping_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Money* p = _impl_.shipping_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& OrderResult::shipping_cost() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.shipping_cost)
  return _internal_shipping_cost();
}
inline void OrderResult::unsafe_arena_set_allocated_shipping_cost(::oteldemo::Money* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shipping_cost_);
  }
  _impl_.shipping_cost_ = reinterpret_cast<::oteldemo::Money*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderResult.shipping_cost)
}
inline ::oteldemo::Money* OrderResult::release_shipping_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* released = _impl_.shipping_cost_;
  _impl_.shipping_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Money* OrderResult::unsafe_arena_release_shipping_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.shipping_cost)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Money* temp = _impl_.shipping_cost_;
  _impl_.shipping_cost_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* OrderResult::_internal_mutable_shipping_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.shipping_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.shipping_cost_ = reinterpret_cast<::oteldemo::Money*>(p);
  }
  return _impl_.shipping_cost_;
}
inline ::oteldemo::Money* OrderResult::mutable_shipping_cost() {
  ::oteldemo::Money* _msg = _internal_mutable_shipping_cost();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.shipping_cost)
  return _msg;
}
inline void OrderResult::set_allocated_shipping_cost(::oteldemo::Money* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Money*>(_impl_.shipping_cost_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Money*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shipping_cost_ = reinterpret_cast<::oteldemo::Money*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.shipping_cost)
}

// .oteldemo.Address shipping_address = 4;
inline bool OrderResult::has_shipping_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shipping_address_ != nullptr);
  return value;
}
inline void OrderResult::clear_shipping_address() {
  if (_impl_.shipping_address_ != nullptr) _impl_.shipping_address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::oteldemo::Address& OrderResult::_internal_shipping_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Address* p = _impl_.shipping_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& OrderResult::shipping_address() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.shipping_address)
  return _internal_shipping_address();
}
inline void OrderResult::unsafe_arena_set_allocated_shipping_address(::oteldemo::Address* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shipping_address_);
  }
  _impl_.shipping_address_ = reinterpret_cast<::oteldemo::Address*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderResult.shipping_address)
}
inline ::oteldemo::Address* OrderResult::release_shipping_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::Address* released = _impl_.shipping_address_;
  _impl_.shipping_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Address* OrderResult::unsafe_arena_release_shipping_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.shipping_address)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::Address* temp = _impl_.shipping_address_;
  _impl_.shipping_address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* OrderResult::_internal_mutable_shipping_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shipping_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.shipping_address_ = reinterpret_cast<::oteldemo::Address*>(p);
  }
  return _impl_.shipping_address_;
}
inline ::oteldemo::Address* OrderResult::mutable_shipping_address() {
  ::oteldemo::Address* _msg = _internal_mutable_shipping_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.shipping_address)
  return _msg;
}
inline void OrderResult::set_allocated_shipping_address(::oteldemo::Address* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Address*>(_impl_.shipping_address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Address*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.shipping_address_ = reinterpret_cast<::oteldemo::Address*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.shipping_address)
}

// repeated .oteldemo.OrderItem items = 5;
inline int OrderResult::_internal_items_size() const {
  return _internal_items().size();
}
inline int OrderResult::items_size() const {
  return _internal_items_size();
}
inline void OrderResult::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::oteldemo::OrderItem* OrderResult::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::OrderItem >*
OrderResult::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.OrderResult.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::oteldemo::OrderItem& OrderResult::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.items)
    return _internal_items().Get(index);
}
inline ::oteldemo::OrderItem* OrderResult::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::OrderItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.OrderResult.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::OrderItem >&
OrderResult::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.OrderResult.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::OrderItem>&
OrderResult::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::OrderItem>*
OrderResult::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// SendOrderConfirmationRequest

// string email = 1;
inline void SendOrderConfirmationRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& SendOrderConfirmationRequest::email() const {
  // @@protoc_insertion_point(field_get:oteldemo.SendOrderConfirmationRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SendOrderConfirmationRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.SendOrderConfirmationRequest.email)
}
inline std::string* SendOrderConfirmationRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:oteldemo.SendOrderConfirmationRequest.email)
  return _s;
}
inline const std::string& SendOrderConfirmationRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void SendOrderConfirmationRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* SendOrderConfirmationRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* SendOrderConfirmationRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.SendOrderConfirmationRequest.email)
  return _impl_.email_.Release();
}
inline void SendOrderConfirmationRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.SendOrderConfirmationRequest.email)
}

// .oteldemo.OrderResult order = 2;
inline bool SendOrderConfirmationRequest::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void SendOrderConfirmationRequest::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::OrderResult& SendOrderConfirmationRequest::_internal_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::OrderResult* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::OrderResult&>(::oteldemo::_OrderResult_default_instance_);
}
inline const ::oteldemo::OrderResult& SendOrderConfirmationRequest::order() const {
  // @@protoc_insertion_point(field_get:oteldemo.SendOrderConfirmationRequest.order)
  return _internal_order();
}
inline void SendOrderConfirmationRequest::unsafe_arena_set_allocated_order(::oteldemo::OrderResult* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = reinterpret_cast<::oteldemo::OrderResult*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.SendOrderConfirmationRequest.order)
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::release_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::OrderResult* released = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::unsafe_arena_release_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.SendOrderConfirmationRequest.order)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::OrderResult* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::_internal_mutable_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::OrderResult>(GetArenaForAllocation());
    _impl_.order_ = reinterpret_cast<::oteldemo::OrderResult*>(p);
  }
  return _impl_.order_;
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::mutable_order() {
  ::oteldemo::OrderResult* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:oteldemo.SendOrderConfirmationRequest.order)
  return _msg;
}
inline void SendOrderConfirmationRequest::set_allocated_order(::oteldemo::OrderResult* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::OrderResult*>(_impl_.order_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::OrderResult*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.order_ = reinterpret_cast<::oteldemo::OrderResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.SendOrderConfirmationRequest.order)
}

// -------------------------------------------------------------------

// PlaceOrderRequest

// string user_id = 1;
inline void PlaceOrderRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& PlaceOrderRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlaceOrderRequest::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.PlaceOrderRequest.user_id)
}
inline std::string* PlaceOrderRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.user_id)
  return _s;
}
inline const std::string& PlaceOrderRequest::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void PlaceOrderRequest::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void PlaceOrderRequest::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.user_id)
}

// string user_currency = 2;
inline void PlaceOrderRequest::clear_user_currency() {
  _impl_.user_currency_.ClearToEmpty();
}
inline const std::string& PlaceOrderRequest::user_currency() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.user_currency)
  return _internal_user_currency();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlaceOrderRequest::set_user_currency(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_currency_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.PlaceOrderRequest.user_currency)
}
inline std::string* PlaceOrderRequest::mutable_user_currency() {
  std::string* _s = _internal_mutable_user_currency();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.user_currency)
  return _s;
}
inline const std::string& PlaceOrderRequest::_internal_user_currency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_currency_.Get();
}
inline void PlaceOrderRequest::_internal_set_user_currency(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_currency_.Set(value, GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::_internal_mutable_user_currency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_currency_.Mutable( GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::release_user_currency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.user_currency)
  return _impl_.user_currency_.Release();
}
inline void PlaceOrderRequest::set_allocated_user_currency(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_currency_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_currency_.IsDefault()) {
          _impl_.user_currency_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.user_currency)
}

// .oteldemo.Address address = 3;
inline bool PlaceOrderRequest::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void PlaceOrderRequest::clear_address() {
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Address& PlaceOrderRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& PlaceOrderRequest::address() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.address)
  return _internal_address();
}
inline void PlaceOrderRequest::unsafe_arena_set_allocated_address(::oteldemo::Address* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.PlaceOrderRequest.address)
}
inline ::oteldemo::Address* PlaceOrderRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Address* released = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Address* PlaceOrderRequest::unsafe_arena_release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* PlaceOrderRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(p);
  }
  return _impl_.address_;
}
inline ::oteldemo::Address* PlaceOrderRequest::mutable_address() {
  ::oteldemo::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.address)
  return _msg;
}
inline void PlaceOrderRequest::set_allocated_address(::oteldemo::Address* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Address*>(_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Address*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::oteldemo::Address*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.address)
}

// string email = 5;
inline void PlaceOrderRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& PlaceOrderRequest::email() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlaceOrderRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.PlaceOrderRequest.email)
}
inline std::string* PlaceOrderRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.email)
  return _s;
}
inline const std::string& PlaceOrderRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void PlaceOrderRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.email)
  return _impl_.email_.Release();
}
inline void PlaceOrderRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.email)
}

// .oteldemo.CreditCardInfo credit_card = 6;
inline bool PlaceOrderRequest::has_credit_card() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.credit_card_ != nullptr);
  return value;
}
inline void PlaceOrderRequest::clear_credit_card() {
  if (_impl_.credit_card_ != nullptr) _impl_.credit_card_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::oteldemo::CreditCardInfo& PlaceOrderRequest::_internal_credit_card() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::CreditCardInfo* p = _impl_.credit_card_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CreditCardInfo&>(::oteldemo::_CreditCardInfo_default_instance_);
}
inline const ::oteldemo::CreditCardInfo& PlaceOrderRequest::credit_card() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.credit_card)
  return _internal_credit_card();
}
inline void PlaceOrderRequest::unsafe_arena_set_allocated_credit_card(::oteldemo::CreditCardInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.credit_card_);
  }
  _impl_.credit_card_ = reinterpret_cast<::oteldemo::CreditCardInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.PlaceOrderRequest.credit_card)
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::release_credit_card() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::CreditCardInfo* released = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::unsafe_arena_release_credit_card() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.credit_card)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::oteldemo::CreditCardInfo* temp = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
  return temp;
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::_internal_mutable_credit_card() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.credit_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CreditCardInfo>(GetArenaForAllocation());
    _impl_.credit_card_ = reinterpret_cast<::oteldemo::CreditCardInfo*>(p);
  }
  return _impl_.credit_card_;
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::mutable_credit_card() {
  ::oteldemo::CreditCardInfo* _msg = _internal_mutable_credit_card();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.credit_card)
  return _msg;
}
inline void PlaceOrderRequest::set_allocated_credit_card(::oteldemo::CreditCardInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::CreditCardInfo*>(_impl_.credit_card_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::CreditCardInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.credit_card_ = reinterpret_cast<::oteldemo::CreditCardInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.credit_card)
}

// -------------------------------------------------------------------

// PlaceOrderResponse

// .oteldemo.OrderResult order = 1;
inline bool PlaceOrderResponse::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void PlaceOrderResponse::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::OrderResult& PlaceOrderResponse::_internal_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::OrderResult* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::OrderResult&>(::oteldemo::_OrderResult_default_instance_);
}
inline const ::oteldemo::OrderResult& PlaceOrderResponse::order() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderResponse.order)
  return _internal_order();
}
inline void PlaceOrderResponse::unsafe_arena_set_allocated_order(::oteldemo::OrderResult* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = reinterpret_cast<::oteldemo::OrderResult*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.PlaceOrderResponse.order)
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::release_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::OrderResult* released = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::unsafe_arena_release_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderResponse.order)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::OrderResult* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::_internal_mutable_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::OrderResult>(GetArenaForAllocation());
    _impl_.order_ = reinterpret_cast<::oteldemo::OrderResult*>(p);
  }
  return _impl_.order_;
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::mutable_order() {
  ::oteldemo::OrderResult* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderResponse.order)
  return _msg;
}
inline void PlaceOrderResponse::set_allocated_order(::oteldemo::OrderResult* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::OrderResult*>(_impl_.order_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::OrderResult*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.order_ = reinterpret_cast<::oteldemo::OrderResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderResponse.order)
}

// -------------------------------------------------------------------

// AdRequest

// repeated string context_keys = 1;
inline int AdRequest::_internal_context_keys_size() const {
  return _internal_context_keys().size();
}
inline int AdRequest::context_keys_size() const {
  return _internal_context_keys_size();
}
inline void AdRequest::clear_context_keys() {
  _internal_mutable_context_keys()->Clear();
}
inline std::string* AdRequest::add_context_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_context_keys()->Add();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.AdRequest.context_keys)
  return _s;
}
inline const std::string& AdRequest::context_keys(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.AdRequest.context_keys)
  return _internal_context_keys().Get(index);
}
inline std::string* AdRequest::mutable_context_keys(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.AdRequest.context_keys)
  return _internal_mutable_context_keys()->Mutable(index);
}
inline void AdRequest::set_context_keys(int index, const std::string& value) {
  _internal_mutable_context_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, std::string&& value) {
  _internal_mutable_context_keys()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_context_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_context_keys()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, absl::string_view value) {
  _internal_mutable_context_keys()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_context_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_context_keys()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_context_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_context_keys()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_context_keys()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:oteldemo.AdRequest.context_keys)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AdRequest::context_keys() const {
  // @@protoc_insertion_point(field_list:oteldemo.AdRequest.context_keys)
  return _internal_context_keys();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* AdRequest::mutable_context_keys() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.AdRequest.context_keys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_context_keys();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AdRequest::_internal_context_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.context_keys_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AdRequest::_internal_mutable_context_keys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.context_keys_;
}

// -------------------------------------------------------------------

// AdResponse

// repeated .oteldemo.Ad ads = 1;
inline int AdResponse::_internal_ads_size() const {
  return _internal_ads().size();
}
inline int AdResponse::ads_size() const {
  return _internal_ads_size();
}
inline void AdResponse::clear_ads() {
  _internal_mutable_ads()->Clear();
}
inline ::oteldemo::Ad* AdResponse::mutable_ads(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.AdResponse.ads)
  return _internal_mutable_ads()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::Ad >*
AdResponse::mutable_ads() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.AdResponse.ads)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ads();
}
inline const ::oteldemo::Ad& AdResponse::ads(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.AdResponse.ads)
    return _internal_ads().Get(index);
}
inline ::oteldemo::Ad* AdResponse::add_ads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::Ad* _add = _internal_mutable_ads()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.AdResponse.ads)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::Ad >&
AdResponse::ads() const {
  // @@protoc_insertion_point(field_list:oteldemo.AdResponse.ads)
  return _internal_ads();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::Ad>&
AdResponse::_internal_ads() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ads_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::Ad>*
AdResponse::_internal_mutable_ads() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ads_;
}

// -------------------------------------------------------------------

// Ad

// string redirect_url = 1;
inline void Ad::clear_redirect_url() {
  _impl_.redirect_url_.ClearToEmpty();
}
inline const std::string& Ad::redirect_url() const {
  // @@protoc_insertion_point(field_get:oteldemo.Ad.redirect_url)
  return _internal_redirect_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Ad::set_redirect_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.redirect_url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Ad.redirect_url)
}
inline std::string* Ad::mutable_redirect_url() {
  std::string* _s = _internal_mutable_redirect_url();
  // @@protoc_insertion_point(field_mutable:oteldemo.Ad.redirect_url)
  return _s;
}
inline const std::string& Ad::_internal_redirect_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.redirect_url_.Get();
}
inline void Ad::_internal_set_redirect_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Ad::_internal_mutable_redirect_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.redirect_url_.Mutable( GetArenaForAllocation());
}
inline std::string* Ad::release_redirect_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Ad.redirect_url)
  return _impl_.redirect_url_.Release();
}
inline void Ad::set_allocated_redirect_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.redirect_url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redirect_url_.IsDefault()) {
          _impl_.redirect_url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Ad.redirect_url)
}

// string text = 2;
inline void Ad::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Ad::text() const {
  // @@protoc_insertion_point(field_get:oteldemo.Ad.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Ad::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Ad.text)
}
inline std::string* Ad::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:oteldemo.Ad.text)
  return _s;
}
inline const std::string& Ad::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void Ad::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Ad::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* Ad::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Ad.text)
  return _impl_.text_.Release();
}
inline void Ad::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Ad.text)
}

// -------------------------------------------------------------------

// Flag

// string name = 1;
inline void Flag::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Flag::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.Flag.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Flag::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Flag.name)
}
inline std::string* Flag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.Flag.name)
  return _s;
}
inline const std::string& Flag::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Flag::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Flag::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Flag::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Flag.name)
  return _impl_.name_.Release();
}
inline void Flag::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Flag.name)
}

// string description = 2;
inline void Flag::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Flag::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.Flag.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Flag::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Flag.description)
}
inline std::string* Flag::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.Flag.description)
  return _s;
}
inline const std::string& Flag::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void Flag::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Flag::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Flag::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.Flag.description)
  return _impl_.description_.Release();
}
inline void Flag::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Flag.description)
}

// bool enabled = 3;
inline void Flag::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool Flag::enabled() const {
  // @@protoc_insertion_point(field_get:oteldemo.Flag.enabled)
  return _internal_enabled();
}
inline void Flag::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:oteldemo.Flag.enabled)
}
inline bool Flag::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void Flag::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// GetFlagRequest

// string name = 1;
inline void GetFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetFlagRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetFlagRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetFlagRequest.name)
}
inline std::string* GetFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetFlagRequest.name)
  return _s;
}
inline const std::string& GetFlagRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetFlagRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlagRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* GetFlagRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetFlagRequest.name)
  return _impl_.name_.Release();
}
inline void GetFlagRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetFlagRequest.name)
}

// -------------------------------------------------------------------

// GetFlagResponse

// .oteldemo.Flag flag = 1;
inline bool GetFlagResponse::has_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flag_ != nullptr);
  return value;
}
inline void GetFlagResponse::clear_flag() {
  if (_impl_.flag_ != nullptr) _impl_.flag_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Flag& GetFlagResponse::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Flag* p = _impl_.flag_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Flag&>(::oteldemo::_Flag_default_instance_);
}
inline const ::oteldemo::Flag& GetFlagResponse::flag() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetFlagResponse.flag)
  return _internal_flag();
}
inline void GetFlagResponse::unsafe_arena_set_allocated_flag(::oteldemo::Flag* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flag_);
  }
  _impl_.flag_ = reinterpret_cast<::oteldemo::Flag*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.GetFlagResponse.flag)
}
inline ::oteldemo::Flag* GetFlagResponse::release_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Flag* released = _impl_.flag_;
  _impl_.flag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Flag* GetFlagResponse::unsafe_arena_release_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.GetFlagResponse.flag)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Flag* temp = _impl_.flag_;
  _impl_.flag_ = nullptr;
  return temp;
}
inline ::oteldemo::Flag* GetFlagResponse::_internal_mutable_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.flag_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Flag>(GetArenaForAllocation());
    _impl_.flag_ = reinterpret_cast<::oteldemo::Flag*>(p);
  }
  return _impl_.flag_;
}
inline ::oteldemo::Flag* GetFlagResponse::mutable_flag() {
  ::oteldemo::Flag* _msg = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetFlagResponse.flag)
  return _msg;
}
inline void GetFlagResponse::set_allocated_flag(::oteldemo::Flag* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Flag*>(_impl_.flag_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Flag*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.flag_ = reinterpret_cast<::oteldemo::Flag*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetFlagResponse.flag)
}

// -------------------------------------------------------------------

// CreateFlagRequest

// string name = 1;
inline void CreateFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateFlagRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CreateFlagRequest.name)
}
inline std::string* CreateFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreateFlagRequest.name)
  return _s;
}
inline const std::string& CreateFlagRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateFlagRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CreateFlagRequest.name)
  return _impl_.name_.Release();
}
inline void CreateFlagRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreateFlagRequest.name)
}

// string description = 2;
inline void CreateFlagRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateFlagRequest::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagRequest.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateFlagRequest::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CreateFlagRequest.description)
}
inline std::string* CreateFlagRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreateFlagRequest.description)
  return _s;
}
inline const std::string& CreateFlagRequest::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void CreateFlagRequest::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CreateFlagRequest.description)
  return _impl_.description_.Release();
}
inline void CreateFlagRequest::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreateFlagRequest.description)
}

// bool enabled = 3;
inline void CreateFlagRequest::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool CreateFlagRequest::enabled() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagRequest.enabled)
  return _internal_enabled();
}
inline void CreateFlagRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreateFlagRequest.enabled)
}
inline bool CreateFlagRequest::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void CreateFlagRequest::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// CreateFlagResponse

// .oteldemo.Flag flag = 1;
inline bool CreateFlagResponse::has_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flag_ != nullptr);
  return value;
}
inline void CreateFlagResponse::clear_flag() {
  if (_impl_.flag_ != nullptr) _impl_.flag_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::oteldemo::Flag& CreateFlagResponse::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::oteldemo::Flag* p = _impl_.flag_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Flag&>(::oteldemo::_Flag_default_instance_);
}
inline const ::oteldemo::Flag& CreateFlagResponse::flag() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagResponse.flag)
  return _internal_flag();
}
inline void CreateFlagResponse::unsafe_arena_set_allocated_flag(::oteldemo::Flag* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flag_);
  }
  _impl_.flag_ = reinterpret_cast<::oteldemo::Flag*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.CreateFlagResponse.flag)
}
inline ::oteldemo::Flag* CreateFlagResponse::release_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Flag* released = _impl_.flag_;
  _impl_.flag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::oteldemo::Flag* CreateFlagResponse::unsafe_arena_release_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.CreateFlagResponse.flag)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::oteldemo::Flag* temp = _impl_.flag_;
  _impl_.flag_ = nullptr;
  return temp;
}
inline ::oteldemo::Flag* CreateFlagResponse::_internal_mutable_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.flag_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Flag>(GetArenaForAllocation());
    _impl_.flag_ = reinterpret_cast<::oteldemo::Flag*>(p);
  }
  return _impl_.flag_;
}
inline ::oteldemo::Flag* CreateFlagResponse::mutable_flag() {
  ::oteldemo::Flag* _msg = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreateFlagResponse.flag)
  return _msg;
}
inline void CreateFlagResponse::set_allocated_flag(::oteldemo::Flag* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::oteldemo::Flag*>(_impl_.flag_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::oteldemo::Flag*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.flag_ = reinterpret_cast<::oteldemo::Flag*>(value);
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreateFlagResponse.flag)
}

// -------------------------------------------------------------------

// UpdateFlagRequest

// string name = 1;
inline void UpdateFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.UpdateFlagRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateFlagRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.UpdateFlagRequest.name)
}
inline std::string* UpdateFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.UpdateFlagRequest.name)
  return _s;
}
inline const std::string& UpdateFlagRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void UpdateFlagRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateFlagRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateFlagRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.UpdateFlagRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateFlagRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.UpdateFlagRequest.name)
}

// bool enabled = 2;
inline void UpdateFlagRequest::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool UpdateFlagRequest::enabled() const {
  // @@protoc_insertion_point(field_get:oteldemo.UpdateFlagRequest.enabled)
  return _internal_enabled();
}
inline void UpdateFlagRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:oteldemo.UpdateFlagRequest.enabled)
}
inline bool UpdateFlagRequest::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void UpdateFlagRequest::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// UpdateFlagResponse

// -------------------------------------------------------------------

// ListFlagsRequest

// -------------------------------------------------------------------

// ListFlagsResponse

// repeated .oteldemo.Flag flag = 1;
inline int ListFlagsResponse::_internal_flag_size() const {
  return _internal_flag().size();
}
inline int ListFlagsResponse::flag_size() const {
  return _internal_flag_size();
}
inline void ListFlagsResponse::clear_flag() {
  _internal_mutable_flag()->Clear();
}
inline ::oteldemo::Flag* ListFlagsResponse::mutable_flag(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListFlagsResponse.flag)
  return _internal_mutable_flag()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oteldemo::Flag >*
ListFlagsResponse::mutable_flag() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListFlagsResponse.flag)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_flag();
}
inline const ::oteldemo::Flag& ListFlagsResponse::flag(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListFlagsResponse.flag)
    return _internal_flag().Get(index);
}
inline ::oteldemo::Flag* ListFlagsResponse::add_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::oteldemo::Flag* _add = _internal_mutable_flag()->Add();
  // @@protoc_insertion_point(field_add:oteldemo.ListFlagsResponse.flag)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::oteldemo::Flag >&
ListFlagsResponse::flag() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListFlagsResponse.flag)
  return _internal_flag();
}
inline const ::google::protobuf::RepeatedPtrField<::oteldemo::Flag>&
ListFlagsResponse::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_;
}
inline ::google::protobuf::RepeatedPtrField<::oteldemo::Flag>*
ListFlagsResponse::_internal_mutable_flag() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.flag_;
}

// -------------------------------------------------------------------

// DeleteFlagRequest

// string name = 1;
inline void DeleteFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.DeleteFlagRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteFlagRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.DeleteFlagRequest.name)
}
inline std::string* DeleteFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.DeleteFlagRequest.name)
  return _s;
}
inline const std::string& DeleteFlagRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DeleteFlagRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFlagRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteFlagRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:oteldemo.DeleteFlagRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteFlagRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.DeleteFlagRequest.name)
}

// -------------------------------------------------------------------

// DeleteFlagResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace oteldemo


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_demo_2eproto_2epb_2eh
